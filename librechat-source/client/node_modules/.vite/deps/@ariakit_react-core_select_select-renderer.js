import __buffer_polyfill from 'vite-plugin-node-polyfills/shims/buffer'
globalThis.Buffer = globalThis.Buffer || __buffer_polyfill
import __global_polyfill from 'vite-plugin-node-polyfills/shims/global'
globalThis.global = globalThis.global || __global_polyfill
import __process_polyfill from 'vite-plugin-node-polyfills/shims/process'
globalThis.process = globalThis.process || __process_polyfill

"use client";
import {
  useSelectContext
} from "./chunk-UCVN5VPG.js";
import {
  __objRest,
  __spreadProps,
  __spreadValues,
  createElement,
  forwardRef2,
  getScrollingElement,
  getWindow,
  invariant,
  shallowEqual,
  toArray,
  useBooleanEvent,
  useCollectionContext,
  useCompositeContext,
  useEvent,
  useForceUpdate,
  useId,
  useMergeRefs,
  useStoreState,
  useWrapElement
} from "./chunk-D4SABNIB.js";
import "./chunk-4DVTD3NX.js";
import {
  require_react_dom
} from "./chunk-ZDP7TQGZ.js";
import {
  require_jsx_runtime
} from "./chunk-XB5JEEIH.js";
import {
  require_react
} from "./chunk-FLN3JEFK.js";
import {
  __toESM,
  require_dist,
  require_dist2,
  require_dist3
} from "./chunk-XN4GCD7D.js";

// ../node_modules/@ariakit/react-core/esm/select/select-renderer.js
var import_dist7 = __toESM(require_dist());
var import_dist8 = __toESM(require_dist2());
var import_dist9 = __toESM(require_dist3());

// ../node_modules/@ariakit/react-core/esm/__chunks/FD7WTSJR.js
var import_dist4 = __toESM(require_dist(), 1);
var import_dist5 = __toESM(require_dist2(), 1);
var import_dist6 = __toESM(require_dist3(), 1);

// ../node_modules/@ariakit/react-core/esm/__chunks/AELVTXWA.js
var import_dist = __toESM(require_dist(), 1);
var import_dist2 = __toESM(require_dist2(), 1);
var import_dist3 = __toESM(require_dist3(), 1);
var import_react = __toESM(require_react(), 1);
var import_react_dom = __toESM(require_react_dom(), 1);
var import_jsx_runtime = __toESM(require_jsx_runtime(), 1);
var TagName = "div";
var CollectionRendererContext = (0, import_react.createContext)(null);
function createTask() {
  let raf = 0;
  const run = (cb) => {
    if (raf) return;
    raf = requestAnimationFrame(() => {
      raf = 0;
      cb();
    });
  };
  const cancel = () => {
    cancelAnimationFrame(raf);
    raf = 0;
  };
  return { run, cancel };
}
function findNearestIndex(items, target, getValue) {
  let left = 0;
  let right = getItemsLength(items) - 1;
  while (left <= right) {
    const index = (left + right) / 2 | 0;
    const value = getValue(index);
    if (value === target) return index;
    else if (value < target) left = index + 1;
    else right = index - 1;
  }
  if (left > 0) return left - 1;
  return 0;
}
function getItemsLength(items) {
  return typeof items === "number" ? items : items.length;
}
function getItemObject(item) {
  if (!item || typeof item !== "object") {
    return { value: item };
  }
  return item;
}
function getItemId(item, index, baseId) {
  var _a;
  invariant(baseId, "CollectionRenderer must be given an `id` prop.");
  const defaultId = `${baseId}/${index}`;
  return (_a = getItemObject(item).id) != null ? _a : defaultId;
}
function getItem(items, index) {
  if (typeof items === "number") {
    if (index >= items) return null;
    return {};
  }
  const item = items[index];
  if (!item) return null;
  if (typeof item === "object") return item;
  return { value: item };
}
function getItemSize(item, horizontal, fallbackElement) {
  var _a, _b, _c, _d, _e;
  const itemObject = getItemObject(item);
  horizontal = itemObject.orientation === "horizontal" || horizontal;
  const prop = horizontal ? "width" : "height";
  const style = itemObject.style;
  if (style) {
    const size = style[prop];
    if (typeof size === "number") return size;
  }
  const items = itemObject.items;
  if (items == null ? void 0 : items.length) {
    const hasSameOrientation = !itemObject.orientation || horizontal && itemObject.orientation === "horizontal" || !horizontal && itemObject.orientation === "vertical";
    const paddingStart = (_b = (_a = itemObject.paddingStart) != null ? _a : itemObject.padding) != null ? _b : 0;
    const paddingEnd = (_d = (_c = itemObject.paddingEnd) != null ? _c : itemObject.padding) != null ? _d : 0;
    const padding = hasSameOrientation ? paddingStart + paddingEnd : 0;
    const initialSize = ((_e = itemObject.gap) != null ? _e : 0) * (items.length - 1) + padding;
    if (hasSameOrientation && itemObject.itemSize) {
      return initialSize + itemObject.itemSize * items.length;
    }
    const totalSize = items.reduce(
      (sum, item2) => sum + getItemSize(item2, horizontal),
      initialSize
    );
    if (totalSize !== initialSize) return totalSize;
  }
  const element = fallbackElement !== false ? itemObject.element || fallbackElement : null;
  if (element == null ? void 0 : element.isConnected) {
    return element.getBoundingClientRect()[prop];
  }
  return 0;
}
function getAverageSize(props) {
  const length = getItemsLength(props.items);
  let currentIndex = 0;
  let averageSize = props.estimatedItemSize;
  const setAverageSize = (size) => {
    const prevIndex = currentIndex;
    currentIndex = currentIndex + 1;
    averageSize = (averageSize * prevIndex + size) / currentIndex;
  };
  for (let index = 0; index < length; index += 1) {
    const item = getItem(props.items, index);
    const itemId = getItemId(item, index, props.baseId);
    const itemData = props.data.get(itemId);
    const fallbackElement = props.elements.get(itemId);
    const size = getItemSize(item, props.horizontal, fallbackElement);
    if (size) {
      setAverageSize(size);
    } else if (itemData == null ? void 0 : itemData.rendered) {
      setAverageSize(itemData.end - itemData.start);
    }
  }
  return averageSize;
}
function getScrollOffset(scroller, horizontal) {
  if ("scrollX" in scroller) {
    return horizontal ? scroller.scrollX : scroller.scrollY;
  }
  return horizontal ? scroller.scrollLeft : scroller.scrollTop;
}
function getViewport(scroller) {
  const { defaultView, documentElement } = scroller.ownerDocument;
  if (scroller === documentElement) return defaultView;
  return scroller;
}
function useScroller(rendererRef) {
  const [scroller, setScroller] = (0, import_react.useState)(null);
  (0, import_react.useEffect)(() => {
    const renderer = rendererRef == null ? void 0 : rendererRef.current;
    if (!renderer) return;
    const scroller2 = getScrollingElement(renderer);
    if (!scroller2) return;
    setScroller(scroller2);
  }, [rendererRef]);
  return scroller;
}
function getRendererOffset(renderer, scroller, horizontal) {
  const win = getWindow(renderer);
  const htmlElement = win == null ? void 0 : win.document.documentElement;
  const rendererRect = renderer.getBoundingClientRect();
  const rendererOffset = horizontal ? rendererRect.left : rendererRect.top;
  if (scroller === htmlElement) {
    const scrollOffset2 = getScrollOffset(win, horizontal);
    return scrollOffset2 + rendererOffset;
  }
  const scrollerRect = scroller.getBoundingClientRect();
  const scrollerOffset = horizontal ? scrollerRect.left : scrollerRect.top;
  const scrollOffset = getScrollOffset(scroller, horizontal);
  return rendererOffset - scrollerOffset + scrollOffset;
}
function getOffsets(renderer, scroller, horizontal) {
  const scrollOffset = getScrollOffset(scroller, horizontal);
  const rendererOffset = getRendererOffset(renderer, scroller, horizontal);
  const scrollSize = horizontal ? scroller.clientWidth : scroller.clientHeight;
  const start = scrollOffset - rendererOffset;
  const end = start + scrollSize;
  return { start, end };
}
function getItemsEnd(props) {
  const length = getItemsLength(props.items);
  const totalPadding = props.paddingStart + props.paddingEnd;
  if (!length) return totalPadding;
  const lastIndex = length - 1;
  const totalGap = lastIndex * props.gap;
  if (props.itemSize != null) {
    return length * props.itemSize + totalGap + totalPadding;
  }
  const defaultEnd = length * props.estimatedItemSize + totalGap + totalPadding;
  if (!props.baseId) return defaultEnd;
  const lastItem = getItem(props.items, lastIndex);
  const lastItemId = getItemId(lastItem, lastIndex, props.baseId);
  const lastItemData = props.data.get(lastItemId);
  if (lastItemData == null ? void 0 : lastItemData.end) return lastItemData.end + props.paddingEnd;
  if (!Array.isArray(props.items)) return defaultEnd;
  const end = props.items.reduce(
    (sum, item) => sum + getItemSize(item, props.horizontal, false),
    0
  );
  if (!end) return defaultEnd;
  return end + totalGap + totalPadding;
}
function getData(props) {
  var _a;
  const length = getItemsLength(props.items);
  let nextData;
  let start = props.paddingStart;
  const avgSize = getAverageSize(props);
  for (let index = 0; index < length; index += 1) {
    const item = getItem(props.items, index);
    const itemId = getItemId(item, index, props.baseId);
    const itemData = props.data.get(itemId);
    const prevRendered = (_a = itemData == null ? void 0 : itemData.rendered) != null ? _a : false;
    const setSize = (size2, rendered = prevRendered) => {
      start = start ? start + props.gap : start;
      const end = start + size2;
      const nextItemData = { index, rendered, start, end };
      if (!shallowEqual(itemData, nextItemData)) {
        if (!nextData) {
          nextData = new Map(props.data);
        }
        nextData.set(itemId, { index, rendered, start, end });
      }
      start = end;
    };
    const size = getItemSize(
      item,
      props.horizontal,
      props.elements.get(itemId)
    );
    if (size) {
      setSize(size, true);
    } else if (itemData == null ? void 0 : itemData.rendered) {
      setSize(itemData.end - itemData.start, true);
    } else {
      setSize(avgSize);
    }
  }
  return nextData;
}
function useCollectionRenderer(_a) {
  var _b = _a, {
    store,
    items: itemsProp,
    initialItems = 0,
    gap = 0,
    itemSize,
    estimatedItemSize = 40,
    overscan: overscanProp,
    orientation: orientationProp,
    padding = 0,
    paddingStart = padding,
    paddingEnd = padding,
    persistentIndices,
    renderOnScroll = true,
    renderOnResize = !!renderOnScroll,
    children: renderItem
  } = _b, props = __objRest(_b, [
    "store",
    "items",
    "initialItems",
    "gap",
    "itemSize",
    "estimatedItemSize",
    "overscan",
    "orientation",
    "padding",
    "paddingStart",
    "paddingEnd",
    "persistentIndices",
    "renderOnScroll",
    "renderOnResize",
    "children"
  ]);
  var _a2, _b2;
  const context = useCollectionContext();
  store = store || context;
  const items = useStoreState(
    store,
    (state) => itemsProp != null ? itemsProp : state == null ? void 0 : state.items
  );
  invariant(
    items != null,
    process.env.NODE_ENV !== "production" && "CollectionRenderer must be either wrapped in a Collection component or be given an `items` prop."
  );
  let parent = (0, import_react.useContext)(CollectionRendererContext);
  if (store && (parent == null ? void 0 : parent.store) !== store) {
    parent = null;
  }
  const parentData = parent == null ? void 0 : parent.childrenData;
  const orientation = (_a2 = orientationProp != null ? orientationProp : parent == null ? void 0 : parent.orientation) != null ? _a2 : "vertical";
  const overscan = (_b2 = overscanProp != null ? overscanProp : parent == null ? void 0 : parent.overscan) != null ? _b2 : 1;
  const ref = (0, import_react.useRef)(null);
  const baseId = useId(props.id);
  const horizontal = orientation === "horizontal";
  const elements = (0, import_react.useMemo)(() => /* @__PURE__ */ new Map(), []);
  const [elementsUpdated, updateElements] = useForceUpdate();
  const [defaultVisibleIndices, setVisibleIndices] = (0, import_react.useState)(() => {
    if (!initialItems) return [];
    const length = getItemsLength(items);
    const initialLength = Math.min(length, Math.abs(initialItems));
    return Array.from({ length: initialLength }, (_, index) => {
      if (initialItems < 0) return length - index - 1;
      return index;
    });
  });
  const visibleIndices = (0, import_react.useMemo)(() => {
    if (!persistentIndices) return defaultVisibleIndices;
    const nextIndices = defaultVisibleIndices.slice();
    for (const index of persistentIndices) {
      if (index < 0) continue;
      if (nextIndices.includes(index)) continue;
      nextIndices.push(index);
    }
    nextIndices.sort((a, b) => a - b);
    if (shallowEqual(defaultVisibleIndices, nextIndices)) {
      return defaultVisibleIndices;
    }
    return nextIndices;
  }, [defaultVisibleIndices, persistentIndices]);
  const [data, setData] = (0, import_react.useState)(() => {
    if (!baseId) return /* @__PURE__ */ new Map();
    const data2 = (parentData == null ? void 0 : parentData.get(baseId)) || /* @__PURE__ */ new Map();
    if (itemSize != null) return data2;
    if (!items) return data2;
    const nextData = getData({
      baseId,
      items,
      data: data2,
      gap,
      elements,
      horizontal,
      paddingStart,
      itemSize,
      estimatedItemSize
    });
    return nextData || data2;
  });
  const totalSize = (0, import_react.useMemo)(() => {
    return getItemsEnd({
      baseId,
      items,
      data,
      gap,
      horizontal,
      itemSize,
      estimatedItemSize,
      paddingStart,
      paddingEnd
    });
  }, [
    baseId,
    items,
    data,
    gap,
    horizontal,
    itemSize,
    estimatedItemSize,
    paddingStart,
    paddingEnd
  ]);
  (0, import_react.useEffect)(() => {
    if (!baseId) return;
    parentData == null ? void 0 : parentData.set(baseId, data);
  }, [baseId, parentData, data]);
  (0, import_react.useEffect)(() => {
    if (itemSize != null) return;
    if (!baseId) return;
    if (!items) return;
    const nextData = getData({
      baseId,
      items,
      data,
      gap,
      elements,
      horizontal,
      paddingStart,
      itemSize,
      estimatedItemSize
    });
    if (nextData) {
      setData(nextData);
    }
  }, [
    elementsUpdated,
    itemSize,
    baseId,
    items,
    data,
    gap,
    elements,
    horizontal,
    paddingStart,
    estimatedItemSize
  ]);
  const scroller = useScroller(items ? ref : null);
  const offsetsRef = (0, import_react.useRef)({ start: 0, end: 0 });
  const processVisibleIndices = (0, import_react.useCallback)(() => {
    const offsets = offsetsRef.current;
    if (!items) return;
    if (!baseId) return;
    if (!offsets.end) return;
    if (!data.size && !itemSize) return;
    const length = getItemsLength(items);
    const getItemOffset = (index, prop = "start") => {
      var _a3;
      if (itemSize) {
        const start2 = itemSize * index + gap * index + paddingStart;
        if (prop === "start") return start2;
        return start2 + itemSize;
      }
      const item = getItem(items, index);
      const itemId = getItemId(item, index, baseId);
      const itemData = data.get(itemId);
      return (_a3 = itemData == null ? void 0 : itemData[prop]) != null ? _a3 : 0;
    };
    const initialStart = findNearestIndex(items, offsets.start, getItemOffset);
    let initialEnd = initialStart;
    while (initialEnd < length && getItemOffset(initialEnd) < offsets.end) {
      initialEnd += 1;
    }
    const finalOverscan = initialEnd - initialStart ? overscan : 0;
    const start = Math.max(initialStart - finalOverscan, 0);
    const end = Math.min(initialEnd + finalOverscan, length);
    const indices = Array.from(
      { length: end - start },
      (_, index) => index + start
    );
    setVisibleIndices((prevIndices) => {
      if (shallowEqual(prevIndices, indices)) return prevIndices;
      return indices;
    });
  }, [
    elementsUpdated,
    items,
    baseId,
    data,
    itemSize,
    gap,
    paddingStart,
    overscan
  ]);
  (0, import_react.useEffect)(processVisibleIndices, [processVisibleIndices]);
  const processVisibleIndicesEvent = useEvent(processVisibleIndices);
  (0, import_react.useEffect)(() => {
    const renderer = ref.current;
    if (!renderer) return;
    if (!scroller) return;
    offsetsRef.current = getOffsets(renderer, scroller, horizontal);
    processVisibleIndicesEvent();
  }, [scroller, horizontal, processVisibleIndicesEvent]);
  const mayRenderOnScroll = !!renderOnScroll;
  const renderOnScrollProp = useBooleanEvent(renderOnScroll);
  (0, import_react.useEffect)(() => {
    if (!mayRenderOnScroll) return;
    const renderer = ref.current;
    if (!renderer) return;
    if (!scroller) return;
    const viewport = getViewport(scroller);
    if (!viewport) return;
    const task = createTask();
    const onScroll = (event) => {
      task.run(() => {
        if (!renderOnScrollProp(event)) return;
        offsetsRef.current = getOffsets(renderer, scroller, horizontal);
        processVisibleIndicesEvent();
      });
    };
    viewport.addEventListener("scroll", onScroll, { passive: true });
    return () => {
      task.cancel();
      viewport.removeEventListener("scroll", onScroll);
    };
  }, [
    mayRenderOnScroll,
    scroller,
    renderOnScrollProp,
    horizontal,
    processVisibleIndicesEvent
  ]);
  const mayRenderOnResize = !!renderOnResize;
  const renderOnResizeProp = useBooleanEvent(renderOnResize);
  (0, import_react.useEffect)(() => {
    if (!mayRenderOnResize) return;
    const renderer = ref.current;
    if (!renderer) return;
    if (!scroller) return;
    const viewport = getViewport(scroller);
    if (!viewport) return;
    const task = createTask();
    if (viewport === scroller) {
      if (typeof ResizeObserver !== "function") return;
      let firstRun = true;
      const observer = new ResizeObserver(() => {
        if (firstRun) {
          firstRun = false;
          return;
        }
        task.run(() => {
          if (!renderOnResizeProp(scroller)) return;
          offsetsRef.current = getOffsets(renderer, scroller, horizontal);
          processVisibleIndicesEvent();
        });
      });
      observer.observe(scroller);
      return () => {
        task.cancel();
        observer.disconnect();
      };
    }
    const onResize = () => {
      task.run(() => {
        if (!renderOnResizeProp(scroller)) return;
        offsetsRef.current = getOffsets(renderer, scroller, horizontal);
        processVisibleIndicesEvent();
      });
    };
    viewport.addEventListener("resize", onResize, { passive: true });
    return () => {
      task.cancel();
      viewport.removeEventListener("resize", onResize);
    };
  }, [
    mayRenderOnResize,
    scroller,
    renderOnResizeProp,
    horizontal,
    processVisibleIndicesEvent
  ]);
  (0, import_react.useEffect)(() => {
    if (typeof IntersectionObserver !== "function") return;
    const renderer = ref.current;
    if (!renderer) return;
    if (!scroller) return;
    const viewport = getViewport(scroller);
    if (!viewport) return;
    const observer = new IntersectionObserver(
      () => {
        offsetsRef.current = getOffsets(renderer, scroller, horizontal);
        processVisibleIndicesEvent();
      },
      { root: scroller === viewport ? scroller : null }
    );
    observer.observe(renderer);
    return () => {
      observer.disconnect();
    };
  }, [scroller, processVisibleIndicesEvent]);
  const elementObserver = (0, import_react.useMemo)(() => {
    if (typeof ResizeObserver !== "function") return;
    return new ResizeObserver(() => {
      (0, import_react_dom.flushSync)(updateElements);
    });
  }, [updateElements]);
  const itemRef = (0, import_react.useCallback)(
    (element) => {
      if (!element) return;
      if (itemSize) return;
      updateElements();
      elements.set(element.id, element);
      elementObserver == null ? void 0 : elementObserver.observe(element);
    },
    [itemSize, elements, updateElements, elementObserver]
  );
  const getItemProps = (0, import_react.useCallback)(
    (item, index) => {
      var _a3, _b3;
      const itemId = getItemId(item, index, baseId);
      const offset = itemSize ? paddingStart + itemSize * index + gap * index : (_b3 = (_a3 = data.get(itemId)) == null ? void 0 : _a3.start) != null ? _b3 : 0;
      const baseItemProps = {
        id: itemId,
        ref: itemRef,
        index,
        style: {
          position: "absolute",
          left: horizontal ? offset : 0,
          top: horizontal ? 0 : offset
        }
      };
      if (itemSize) {
        baseItemProps.style[horizontal ? "width" : "height"] = itemSize;
      }
      if (item == null) return baseItemProps;
      const itemProps = getItemObject(item);
      return __spreadProps(__spreadValues(__spreadValues({}, itemProps), baseItemProps), {
        style: __spreadValues(__spreadValues({}, itemProps.style), baseItemProps.style)
      });
    },
    [baseId, data, itemSize, paddingStart, gap, horizontal, itemRef]
  );
  const itemsProps = (0, import_react.useMemo)(() => {
    return visibleIndices.map((index) => {
      if (index < 0) return;
      const item = getItem(items, index);
      if (!item) return;
      return getItemProps(item, index);
    }).filter((value) => value != null);
  }, [items, visibleIndices, getItemProps]);
  const children = itemsProps == null ? void 0 : itemsProps.map((itemProps) => {
    return renderItem == null ? void 0 : renderItem(itemProps);
  });
  const styleProp = props.style;
  const sizeProperty = horizontal ? "width" : "height";
  const style = (0, import_react.useMemo)(
    () => __spreadValues({
      flex: "none",
      position: "relative",
      [sizeProperty]: totalSize
    }, styleProp),
    [styleProp, sizeProperty, totalSize]
  );
  const childrenData = (0, import_react.useMemo)(() => /* @__PURE__ */ new Map(), []);
  const providerValue = (0, import_react.useMemo)(
    () => ({ store, orientation, overscan, childrenData }),
    [store, orientation, overscan, childrenData]
  );
  props = useWrapElement(
    props,
    (element) => (0, import_jsx_runtime.jsx)(CollectionRendererContext.Provider, { value: providerValue, children: element }),
    [providerValue]
  );
  props = __spreadProps(__spreadValues({
    id: baseId
  }, props), {
    style,
    ref: useMergeRefs(ref, props.ref)
  });
  return __spreadProps(__spreadValues({}, props), { children });
}
var CollectionRenderer = forwardRef2(function CollectionRenderer2(props) {
  const htmlProps = useCollectionRenderer(props);
  return createElement(TagName, htmlProps);
});
var getCollectionRendererItem = getItem;
var getCollectionRendererItemId = getItemId;

// ../node_modules/@ariakit/react-core/esm/__chunks/FD7WTSJR.js
var import_react2 = __toESM(require_react(), 1);
var TagName2 = "div";
function getItemObject2(item) {
  if (!item || typeof item !== "object") {
    return { value: item };
  }
  return item;
}
function countItems(items) {
  if (!items) return [0];
  if (typeof items === "number") {
    return Array.from({ length: items }, (_, index) => index + 1);
  }
  return items.reduce((count, item, index) => {
    var _a, _b;
    const object = getItemObject2(item);
    if (!object.items) {
    }
    if (!object.items) {
      count[index] = index + 1;
      return count;
    }
    const prevCount = (_a = count[index - 1]) != null ? _a : 0;
    const itemsCount = (_b = countItems(object.items)[object.items.length - 1]) != null ? _b : 0;
    count[index] = prevCount + itemsCount;
    return count;
  }, []);
}
function findFirst(items, offset = 1) {
  for (let index = offset > 0 ? 0 : items.length - 1; index >= 0 && index < items.length; index += offset) {
    const item = items[index];
    const object = getItemObject2(item);
    if (object.items && findFirst(object.items, offset) !== -1) return index;
    if (!object.disabled) return index;
  }
  return -1;
}
function findLast(items) {
  return findFirst(items, -1);
}
function findById(items, id, baseId) {
  return items.findIndex((item, index) => {
    var _a;
    const itemId = getCollectionRendererItemId(item, index, baseId);
    if (itemId === id) return true;
    const object = getItemObject2(item);
    if ((_a = object.items) == null ? void 0 : _a.length) return findById(object.items, id, itemId) !== -1;
    const ids = id.split("/");
    if (ids.length === 1) return false;
    return ids.some((id2) => itemId === id2);
  });
}
function useCompositeRenderer(_a) {
  var _b = _a, {
    store,
    orientation: orientationProp,
    persistentIndices: persistentIndicesProp,
    children: renderItem,
    "aria-setsize": ariaSetSize,
    "aria-posinset": ariaPosInSet = 1
  } = _b, props = __objRest(_b, [
    "store",
    "orientation",
    "persistentIndices",
    "children",
    "aria-setsize",
    "aria-posinset"
  ]);
  const context = useCompositeContext();
  store = store || context;
  const orientation = useStoreState(
    store,
    (state) => (orientationProp != null ? orientationProp : (state == null ? void 0 : state.orientation) === "both") ? "vertical" : state == null ? void 0 : state.orientation
  );
  const items = useStoreState(store, (state) => {
    var _a2;
    if (!state) return props.items;
    if ("mounted" in state && !state.mounted) return 0;
    return (_a2 = props.items) != null ? _a2 : state.items;
  });
  const id = useId(props.id);
  const itemsCount = (0, import_react2.useMemo)(() => countItems(items), [items]);
  const setSize = (0, import_react2.useMemo)(
    () => {
      var _a2;
      return (_a2 = ariaSetSize != null ? ariaSetSize : itemsCount[itemsCount.length - 1]) != null ? _a2 : 0;
    },
    [ariaSetSize, itemsCount]
  );
  const firstIndex = (0, import_react2.useMemo)(() => {
    if (!items) return -1;
    if (typeof items === "number") return 0;
    if (!items.length) return -1;
    return findFirst(items);
  }, [items]);
  const lastIndex = (0, import_react2.useMemo)(() => {
    if (!items) return -1;
    if (typeof items === "number") return items - 1;
    if (!items.length) return -1;
    return findLast(items);
  }, [items]);
  const activeId = useStoreState(store, "activeId");
  const activeIndex = (0, import_react2.useMemo)(() => {
    if (!id) return -1;
    if (!items) return -1;
    if (activeId == null) return -1;
    if (typeof items === "number") return -1;
    if (!items.length) return -1;
    return findById(items, activeId, id);
  }, [id, items, activeId]);
  const persistentIndices = (0, import_react2.useMemo)(() => {
    const indices = [firstIndex, activeIndex, lastIndex].filter(
      (index) => index >= 0
    );
    if (persistentIndicesProp) {
      return [...persistentIndicesProp, ...indices];
    }
    return indices;
  }, [firstIndex, activeIndex, lastIndex, persistentIndicesProp]);
  return useCollectionRenderer(__spreadProps(__spreadValues({
    id,
    store,
    orientation,
    persistentIndices
  }, props), {
    children: (item) => {
      var _a2;
      const nextItem = __spreadProps(__spreadValues({}, item), {
        "aria-setsize": setSize,
        "aria-posinset": ariaPosInSet + ((_a2 = itemsCount[item.index - 1]) != null ? _a2 : 0)
      });
      return renderItem == null ? void 0 : renderItem(nextItem);
    }
  }));
}
var CompositeRenderer = forwardRef2(function CompositeRenderer2(props) {
  const htmlProps = useCompositeRenderer(props);
  return createElement(TagName2, htmlProps);
});

// ../node_modules/@ariakit/react-core/esm/select/select-renderer.js
var import_react3 = __toESM(require_react());
var TagName3 = "div";
function getItemObject3(item) {
  if (!item || typeof item !== "object") {
    return { value: `${item}` };
  }
  return item;
}
function findIndicesByValue(items, value) {
  var _a;
  const values = toArray(value);
  const indices = [];
  for (const [index, item] of items.entries()) {
    if (indices.length === values.length) break;
    const object = getItemObject3(item);
    if (object.value != null && values.includes(object.value)) {
      indices.push(index);
    } else if ((_a = object.items) == null ? void 0 : _a.length) {
      const childIndices = findIndicesByValue(object.items, value);
      if (childIndices.length) {
        indices.push(index);
      }
    }
  }
  return indices;
}
function useSelectRenderer(_a) {
  var _b = _a, {
    store,
    orientation: orientationProp,
    persistentIndices: persistentIndicesProp,
    items: itemsProp,
    value: valueProp
  } = _b, props = __objRest(_b, [
    "store",
    "orientation",
    "persistentIndices",
    "items",
    "value"
  ]);
  const context = useSelectContext();
  store = store || context;
  const items = useStoreState(store, (state) => {
    if (!state) return itemsProp;
    if (!state.mounted) return 0;
    return itemsProp != null ? itemsProp : state.items;
  });
  const value = useStoreState(store, (state) => valueProp != null ? valueProp : state == null ? void 0 : state.value);
  const valueIndices = (0, import_react3.useMemo)(() => {
    if (!items) return [];
    if (value == null) return [];
    if (typeof items === "number") return [];
    if (!items.length) return [];
    return findIndicesByValue(items, value);
  }, [items, value]);
  const persistentIndices = (0, import_react3.useMemo)(() => {
    if (persistentIndicesProp) {
      return [...persistentIndicesProp, ...valueIndices];
    }
    return valueIndices;
  }, [valueIndices, persistentIndicesProp]);
  return useCompositeRenderer(__spreadValues({
    store,
    items,
    persistentIndices
  }, props));
}
var SelectRenderer = forwardRef2(function SelectRenderer2(props) {
  const htmlProps = useSelectRenderer(props);
  return createElement(TagName3, htmlProps);
});
export {
  SelectRenderer,
  getCollectionRendererItem as getSelectRendererItem,
  getCollectionRendererItemId as getSelectRendererItemId
};
//# sourceMappingURL=@ariakit_react-core_select_select-renderer.js.map
