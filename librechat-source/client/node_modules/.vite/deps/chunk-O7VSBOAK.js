import __buffer_polyfill from 'vite-plugin-node-polyfills/shims/buffer'
globalThis.Buffer = globalThis.Buffer || __buffer_polyfill
import __global_polyfill from 'vite-plugin-node-polyfills/shims/global'
globalThis.global = globalThis.global || __global_polyfill
import __process_polyfill from 'vite-plugin-node-polyfills/shims/process'
globalThis.process = globalThis.process || __process_polyfill

import {
  CheckboxCheckedContext,
  Role,
  createCompositeStore,
  createDialogComponent,
  createPopoverStore,
  hasFocusWithin,
  isHidden,
  useCheckboxCheck,
  useComboboxProviderContext,
  useCommand,
  useComposite,
  useCompositeGroup,
  useCompositeGroupLabel,
  useCompositeHover,
  useCompositeItem,
  useCompositeSeparator,
  useCompositeStoreProps,
  useCompositeTypeahead,
  useFocusable,
  usePopover,
  usePopoverDisclosure,
  usePopoverDisclosureArrow,
  usePopoverDismiss,
  usePopoverHeading,
  usePopoverStoreProps
} from "./chunk-2QK6SJTQ.js";
import {
  CompositeContextProvider,
  CompositeScopedContextProvider,
  DialogDescriptionContext,
  PopoverContextProvider,
  PopoverScopedContextProvider,
  __objRest,
  __objRest2,
  __spreadProps,
  __spreadProps2,
  __spreadValues,
  __spreadValues2,
  addGlobalEventListener,
  applyState,
  chain,
  contains,
  createElement,
  createHook,
  createStore,
  createStoreContext,
  defaultValue,
  disabledFromProps,
  fireEvent,
  forwardRef2,
  getDocument,
  getPopupItemRole,
  getPopupRole,
  getWindow,
  invariant,
  isDownloading,
  isFalsyBooleanCallback,
  isOpeningInNewTab,
  memo2,
  mergeStore,
  omit2,
  pick2,
  removeUndefinedValues,
  setup,
  shallowEqual,
  sync,
  throwOnConflictingProps,
  useBooleanEvent,
  useEvent,
  useForceUpdate,
  useId,
  useInitialValue,
  useIsMouseMoving,
  useLiveRef,
  useMergeRefs,
  usePopoverContext,
  usePortalRef,
  useSafeLayoutEffect,
  useStore,
  useStoreProps,
  useStoreState,
  useTagName,
  useUpdateEffect,
  useWrapElement
} from "./chunk-D4SABNIB.js";
import {
  require_jsx_runtime
} from "./chunk-XB5JEEIH.js";
import {
  require_react
} from "./chunk-FLN3JEFK.js";
import {
  __toESM,
  require_dist,
  require_dist2,
  require_dist3
} from "./chunk-XN4GCD7D.js";

// ../node_modules/@ariakit/react-core/esm/__chunks/62UHHO2X.js
var import_dist = __toESM(require_dist(), 1);
var import_dist2 = __toESM(require_dist2(), 1);
var import_dist3 = __toESM(require_dist3(), 1);
var import_react = __toESM(require_react(), 1);
var menubar = createStoreContext(
  [CompositeContextProvider],
  [CompositeScopedContextProvider]
);
var useMenubarContext = menubar.useContext;
var useMenubarScopedContext = menubar.useScopedContext;
var useMenubarProviderContext = menubar.useProviderContext;
var MenubarContextProvider = menubar.ContextProvider;
var MenubarScopedContextProvider = menubar.ScopedContextProvider;
var MenuItemCheckedContext = (0, import_react.createContext)(
  void 0
);

// ../node_modules/@ariakit/react-core/esm/__chunks/EM5CXX6A.js
var import_dist4 = __toESM(require_dist(), 1);
var import_dist5 = __toESM(require_dist2(), 1);
var import_dist6 = __toESM(require_dist3(), 1);
var ctx = createStoreContext(
  [PopoverContextProvider],
  [PopoverScopedContextProvider]
);
var useHovercardContext = ctx.useContext;
var useHovercardScopedContext = ctx.useScopedContext;
var useHovercardProviderContext = ctx.useProviderContext;
var HovercardContextProvider = ctx.ContextProvider;
var HovercardScopedContextProvider = ctx.ScopedContextProvider;

// ../node_modules/@ariakit/react-core/esm/__chunks/VIIRIBF3.js
var import_dist7 = __toESM(require_dist(), 1);
var import_dist8 = __toESM(require_dist2(), 1);
var import_dist9 = __toESM(require_dist3(), 1);
var import_react2 = __toESM(require_react(), 1);
var menu = createStoreContext(
  [CompositeContextProvider, HovercardContextProvider],
  [CompositeScopedContextProvider, HovercardScopedContextProvider]
);
var useMenuContext = menu.useContext;
var useMenuScopedContext = menu.useScopedContext;
var useMenuProviderContext = menu.useProviderContext;
var MenuContextProvider = menu.ContextProvider;
var MenuScopedContextProvider = menu.ScopedContextProvider;
var useMenuBarContext = useMenubarContext;
var MenuItemCheckedContext2 = (0, import_react2.createContext)(
  void 0
);

// ../node_modules/@ariakit/react-core/esm/__chunks/FTXTWCCT.js
var import_dist16 = __toESM(require_dist(), 1);
var import_dist17 = __toESM(require_dist2(), 1);
var import_dist18 = __toESM(require_dist3(), 1);

// ../node_modules/@ariakit/core/esm/hovercard/hovercard-store.js
var import_dist13 = __toESM(require_dist());
var import_dist14 = __toESM(require_dist2());
var import_dist15 = __toESM(require_dist3());

// ../node_modules/@ariakit/core/esm/__chunks/JTLIIJ4U.js
var import_dist10 = __toESM(require_dist(), 1);
var import_dist11 = __toESM(require_dist2(), 1);
var import_dist12 = __toESM(require_dist3(), 1);
function createHovercardStore(props = {}) {
  var _a;
  const syncState = (_a = props.store) == null ? void 0 : _a.getState();
  const popover = createPopoverStore(__spreadProps2(__spreadValues2({}, props), {
    placement: defaultValue(
      props.placement,
      syncState == null ? void 0 : syncState.placement,
      "bottom"
    )
  }));
  const timeout = defaultValue(props.timeout, syncState == null ? void 0 : syncState.timeout, 500);
  const initialState = __spreadProps2(__spreadValues2({}, popover.getState()), {
    timeout,
    showTimeout: defaultValue(props.showTimeout, syncState == null ? void 0 : syncState.showTimeout),
    hideTimeout: defaultValue(props.hideTimeout, syncState == null ? void 0 : syncState.hideTimeout),
    autoFocusOnShow: defaultValue(syncState == null ? void 0 : syncState.autoFocusOnShow, false)
  });
  const hovercard = createStore(initialState, popover, props.store);
  return __spreadProps2(__spreadValues2(__spreadValues2({}, popover), hovercard), {
    setAutoFocusOnShow: (value) => hovercard.setState("autoFocusOnShow", value)
  });
}

// ../node_modules/@ariakit/react-core/esm/__chunks/FTXTWCCT.js
function useHovercardStoreProps(store, update, props) {
  useStoreProps(store, props, "timeout");
  useStoreProps(store, props, "showTimeout");
  useStoreProps(store, props, "hideTimeout");
  return usePopoverStoreProps(store, update, props);
}
function useHovercardStore(props = {}) {
  const [store, update] = useStore(createHovercardStore, props);
  return useHovercardStoreProps(store, update, props);
}

// ../node_modules/@ariakit/react-core/esm/__chunks/U2E5GZTC.js
var import_dist22 = __toESM(require_dist(), 1);
var import_dist23 = __toESM(require_dist2(), 1);
var import_dist24 = __toESM(require_dist3(), 1);

// ../node_modules/@ariakit/core/esm/menu/menu-store.js
var import_dist19 = __toESM(require_dist());
var import_dist20 = __toESM(require_dist2());
var import_dist21 = __toESM(require_dist3());
function createMenuStore(_a = {}) {
  var _b = _a, {
    combobox,
    parent,
    menubar: menubar2
  } = _b, props = __objRest2(_b, [
    "combobox",
    "parent",
    "menubar"
  ]);
  const parentIsMenubar = !!menubar2 && !parent;
  const store = mergeStore(
    props.store,
    pick2(parent, ["values"]),
    omit2(combobox, [
      "arrowElement",
      "anchorElement",
      "contentElement",
      "popoverElement",
      "disclosureElement"
    ])
  );
  throwOnConflictingProps(props, store);
  const syncState = store.getState();
  const composite = createCompositeStore(__spreadProps2(__spreadValues2({}, props), {
    store,
    orientation: defaultValue(
      props.orientation,
      syncState.orientation,
      "vertical"
    )
  }));
  const hovercard = createHovercardStore(__spreadProps2(__spreadValues2({}, props), {
    store,
    placement: defaultValue(
      props.placement,
      syncState.placement,
      "bottom-start"
    ),
    timeout: defaultValue(
      props.timeout,
      syncState.timeout,
      parentIsMenubar ? 0 : 150
    ),
    hideTimeout: defaultValue(props.hideTimeout, syncState.hideTimeout, 0)
  }));
  const initialState = __spreadProps2(__spreadValues2(__spreadValues2({}, composite.getState()), hovercard.getState()), {
    initialFocus: defaultValue(syncState.initialFocus, "container"),
    values: defaultValue(
      props.values,
      syncState.values,
      props.defaultValues,
      {}
    )
  });
  const menu2 = createStore(initialState, composite, hovercard, store);
  setup(
    menu2,
    () => sync(menu2, ["mounted"], (state) => {
      if (state.mounted) return;
      menu2.setState("activeId", null);
    })
  );
  setup(
    menu2,
    () => sync(parent, ["orientation"], (state) => {
      menu2.setState(
        "placement",
        state.orientation === "vertical" ? "right-start" : "bottom-start"
      );
    })
  );
  return __spreadProps2(__spreadValues2(__spreadValues2(__spreadValues2({}, composite), hovercard), menu2), {
    combobox,
    parent,
    menubar: menubar2,
    hideAll: () => {
      hovercard.hide();
      parent == null ? void 0 : parent.hideAll();
    },
    setInitialFocus: (value) => menu2.setState("initialFocus", value),
    setValues: (values) => menu2.setState("values", values),
    setValue: (name, value) => {
      if (name === "__proto__") return;
      if (name === "constructor") return;
      if (Array.isArray(name)) return;
      menu2.setState("values", (values) => {
        const prevValue = values[name];
        const nextValue = applyState(value, prevValue);
        if (nextValue === prevValue) return values;
        return __spreadProps2(__spreadValues2({}, values), {
          [name]: nextValue !== void 0 && nextValue
        });
      });
    }
  });
}

// ../node_modules/@ariakit/react-core/esm/__chunks/U2E5GZTC.js
function useMenuStoreProps(store, update, props) {
  useUpdateEffect(update, [props.combobox, props.parent, props.menubar]);
  useStoreProps(store, props, "values", "setValues");
  return Object.assign(
    useHovercardStoreProps(
      useCompositeStoreProps(store, update, props),
      update,
      props
    ),
    {
      combobox: props.combobox,
      parent: props.parent,
      menubar: props.menubar
    }
  );
}
function useMenuStore(props = {}) {
  const parent = useMenuContext();
  const menubar2 = useMenubarContext();
  const combobox = useComboboxProviderContext();
  props = __spreadProps(__spreadValues({}, props), {
    parent: props.parent !== void 0 ? props.parent : parent,
    menubar: props.menubar !== void 0 ? props.menubar : menubar2,
    combobox: props.combobox !== void 0 ? props.combobox : combobox
  });
  const [store, update] = useStore(createMenuStore, props);
  return useMenuStoreProps(store, update, props);
}

// ../node_modules/@ariakit/react-core/esm/menu/menu-store.js
var import_dist25 = __toESM(require_dist());
var import_dist26 = __toESM(require_dist2());
var import_dist27 = __toESM(require_dist3());

// ../node_modules/@ariakit/react-core/esm/menu/menu-context.js
var import_dist28 = __toESM(require_dist());
var import_dist29 = __toESM(require_dist2());
var import_dist30 = __toESM(require_dist3());

// ../node_modules/@ariakit/react-core/esm/__chunks/BKQBQI36.js
var import_dist37 = __toESM(require_dist(), 1);
var import_dist38 = __toESM(require_dist2(), 1);
var import_dist39 = __toESM(require_dist3(), 1);

// ../node_modules/@ariakit/core/esm/menubar/menubar-store.js
var import_dist34 = __toESM(require_dist());
var import_dist35 = __toESM(require_dist2());
var import_dist36 = __toESM(require_dist3());

// ../node_modules/@ariakit/core/esm/__chunks/PQ5AROUB.js
var import_dist31 = __toESM(require_dist(), 1);
var import_dist32 = __toESM(require_dist2(), 1);
var import_dist33 = __toESM(require_dist3(), 1);
function createMenubarStore(props = {}) {
  var _a;
  const syncState = (_a = props.store) == null ? void 0 : _a.getState();
  const composite = createCompositeStore(__spreadProps2(__spreadValues2({}, props), {
    orientation: defaultValue(
      props.orientation,
      syncState == null ? void 0 : syncState.orientation,
      "horizontal"
    ),
    focusLoop: defaultValue(props.focusLoop, syncState == null ? void 0 : syncState.focusLoop, true)
  }));
  const initialState = __spreadValues2({}, composite.getState());
  const menubar2 = createStore(initialState, composite, props.store);
  return __spreadValues2(__spreadValues2({}, composite), menubar2);
}

// ../node_modules/@ariakit/react-core/esm/__chunks/BKQBQI36.js
function useMenubarStoreProps(store, update, props) {
  return useCompositeStoreProps(store, update, props);
}
function useMenubarStore(props = {}) {
  const [store, update] = useStore(createMenubarStore, props);
  return useMenubarStoreProps(store, update, props);
}

// ../node_modules/@ariakit/react-core/esm/menu/menu-bar-store.js
var import_dist40 = __toESM(require_dist());
var import_dist41 = __toESM(require_dist2());
var import_dist42 = __toESM(require_dist3());
var import_react3 = __toESM(require_react());
function useMenuBarStore(props = {}) {
  (0, import_react3.useEffect)(() => {
    if (process.env.NODE_ENV !== "production") {
      console.warn(
        "useMenuBarStore is deprecated. Use useMenubarStore instead.",
        "See https://ariakit.org/reference/use-menubar-store"
      );
    }
  }, []);
  return useMenubarStore(props);
}

// ../node_modules/@ariakit/react-core/esm/__chunks/MDUNURGC.js
var import_dist43 = __toESM(require_dist(), 1);
var import_dist44 = __toESM(require_dist2(), 1);
var import_dist45 = __toESM(require_dist3(), 1);
var import_react4 = __toESM(require_react(), 1);
var import_jsx_runtime = __toESM(require_jsx_runtime(), 1);
var TagName = "div";
function useAriaLabelledBy(_a) {
  var _b = _a, { store } = _b, props = __objRest(_b, ["store"]);
  const [id, setId] = (0, import_react4.useState)(void 0);
  const label = props["aria-label"];
  const disclosureElement = useStoreState(store, "disclosureElement");
  const contentElement = useStoreState(store, "contentElement");
  (0, import_react4.useEffect)(() => {
    const disclosure = disclosureElement;
    if (!disclosure) return;
    const menu2 = contentElement;
    if (!menu2) return;
    const menuLabel = label || menu2.hasAttribute("aria-label");
    if (menuLabel) {
      setId(void 0);
    } else if (disclosure.id) {
      setId(disclosure.id);
    }
  }, [label, disclosureElement, contentElement]);
  return id;
}
var useMenuList = createHook(
  function useMenuList2(_a) {
    var _b = _a, { store, alwaysVisible, composite } = _b, props = __objRest(_b, ["store", "alwaysVisible", "composite"]);
    const context = useMenuProviderContext();
    store = store || context;
    invariant(
      store,
      process.env.NODE_ENV !== "production" && "MenuList must receive a `store` prop or be wrapped in a MenuProvider component."
    );
    const parentMenu = store.parent;
    const parentMenubar = store.menubar;
    const hasParentMenu = !!parentMenu;
    const id = useId(props.id);
    const onKeyDownProp = props.onKeyDown;
    const dir = store.useState(
      (state) => state.placement.split("-")[0]
    );
    const orientation = store.useState(
      (state) => state.orientation === "both" ? void 0 : state.orientation
    );
    const isHorizontal = orientation !== "vertical";
    const isMenubarHorizontal = useStoreState(
      parentMenubar,
      (state) => !!state && state.orientation !== "vertical"
    );
    const onKeyDown = useEvent((event) => {
      onKeyDownProp == null ? void 0 : onKeyDownProp(event);
      if (event.defaultPrevented) return;
      if (hasParentMenu || parentMenubar && !isHorizontal) {
        const hideMap = {
          ArrowRight: () => dir === "left" && !isHorizontal,
          ArrowLeft: () => dir === "right" && !isHorizontal,
          ArrowUp: () => dir === "bottom" && isHorizontal,
          ArrowDown: () => dir === "top" && isHorizontal
        };
        const action = hideMap[event.key];
        if (action == null ? void 0 : action()) {
          event.stopPropagation();
          event.preventDefault();
          return store == null ? void 0 : store.hide();
        }
      }
      if (parentMenubar) {
        const keyMap = {
          ArrowRight: () => {
            if (!isMenubarHorizontal) return;
            return parentMenubar.next();
          },
          ArrowLeft: () => {
            if (!isMenubarHorizontal) return;
            return parentMenubar.previous();
          },
          ArrowDown: () => {
            if (isMenubarHorizontal) return;
            return parentMenubar.next();
          },
          ArrowUp: () => {
            if (isMenubarHorizontal) return;
            return parentMenubar.previous();
          }
        };
        const action = keyMap[event.key];
        const id2 = action == null ? void 0 : action();
        if (id2 !== void 0) {
          event.stopPropagation();
          event.preventDefault();
          parentMenubar.move(id2);
        }
      }
    });
    props = useWrapElement(
      props,
      (element) => (0, import_jsx_runtime.jsx)(MenuScopedContextProvider, { value: store, children: element }),
      [store]
    );
    const ariaLabelledBy = useAriaLabelledBy(__spreadValues({ store }, props));
    const mounted = store.useState("mounted");
    const hidden = isHidden(mounted, props.hidden, alwaysVisible);
    const style = hidden ? __spreadProps(__spreadValues({}, props.style), { display: "none" }) : props.style;
    props = __spreadProps(__spreadValues({
      id,
      "aria-labelledby": ariaLabelledBy,
      hidden
    }, props), {
      ref: useMergeRefs(id ? store.setContentElement : null, props.ref),
      style,
      onKeyDown
    });
    const hasCombobox = !!store.combobox;
    composite = composite != null ? composite : !hasCombobox;
    if (composite) {
      props = __spreadValues({
        role: "menu",
        "aria-orientation": orientation
      }, props);
    }
    props = useComposite(__spreadValues({ store, composite }, props));
    props = useCompositeTypeahead(__spreadValues({ store, typeahead: !hasCombobox }, props));
    return props;
  }
);
var MenuList = forwardRef2(function MenuList2(props) {
  const htmlProps = useMenuList(props);
  return createElement(TagName, htmlProps);
});

// ../node_modules/@ariakit/react-core/esm/__chunks/ZFX5QU3H.js
var import_dist49 = __toESM(require_dist(), 1);
var import_dist50 = __toESM(require_dist2(), 1);
var import_dist51 = __toESM(require_dist3(), 1);

// ../node_modules/@ariakit/react-core/esm/__chunks/X7QOZUD3.js
var import_dist46 = __toESM(require_dist(), 1);
var import_dist47 = __toESM(require_dist2(), 1);
var import_dist48 = __toESM(require_dist3(), 1);
function getEventPoint(event) {
  return [event.clientX, event.clientY];
}
function isPointInPolygon(point, polygon) {
  const [x, y] = point;
  let inside = false;
  const length = polygon.length;
  for (let l = length, i = 0, j = l - 1; i < l; j = i++) {
    const [xi, yi] = polygon[i];
    const [xj, yj] = polygon[j];
    const [, vy] = polygon[j === 0 ? l - 1 : j - 1] || [0, 0];
    const where = (yi - yj) * (x - xi) - (xi - xj) * (y - yi);
    if (yj < yi) {
      if (y >= yj && y < yi) {
        if (where === 0) return true;
        if (where > 0) {
          if (y === yj) {
            if (y > vy) {
              inside = !inside;
            }
          } else {
            inside = !inside;
          }
        }
      }
    } else if (yi < yj) {
      if (y > yi && y <= yj) {
        if (where === 0) return true;
        if (where < 0) {
          if (y === yj) {
            if (y < vy) {
              inside = !inside;
            }
          } else {
            inside = !inside;
          }
        }
      }
    } else if (y === yi && (x >= xj && x <= xi || x >= xi && x <= xj)) {
      return true;
    }
  }
  return inside;
}
function getEnterPointPlacement(enterPoint, rect) {
  const { top, right, bottom, left } = rect;
  const [x, y] = enterPoint;
  const placementX = x < left ? "left" : x > right ? "right" : null;
  const placementY = y < top ? "top" : y > bottom ? "bottom" : null;
  return [placementX, placementY];
}
function getElementPolygon(element, enterPoint) {
  const rect = element.getBoundingClientRect();
  const { top, right, bottom, left } = rect;
  const [x, y] = getEnterPointPlacement(enterPoint, rect);
  const polygon = [enterPoint];
  if (x) {
    if (y !== "top") {
      polygon.push([x === "left" ? left : right, top]);
    }
    polygon.push([x === "left" ? right : left, top]);
    polygon.push([x === "left" ? right : left, bottom]);
    if (y !== "bottom") {
      polygon.push([x === "left" ? left : right, bottom]);
    }
  } else if (y === "top") {
    polygon.push([left, top]);
    polygon.push([left, bottom]);
    polygon.push([right, bottom]);
    polygon.push([right, top]);
  } else {
    polygon.push([left, bottom]);
    polygon.push([left, top]);
    polygon.push([right, top]);
    polygon.push([right, bottom]);
  }
  return polygon;
}

// ../node_modules/@ariakit/react-core/esm/__chunks/ZFX5QU3H.js
var import_react5 = __toESM(require_react(), 1);
var import_jsx_runtime2 = __toESM(require_jsx_runtime(), 1);
var TagName2 = "div";
function isMovingOnHovercard(target, card, anchor, nested) {
  if (hasFocusWithin(card)) return true;
  if (!target) return false;
  if (contains(card, target)) return true;
  if (anchor && contains(anchor, target)) return true;
  if (nested == null ? void 0 : nested.some((card2) => isMovingOnHovercard(target, card2, anchor))) {
    return true;
  }
  return false;
}
function useAutoFocusOnHide(_a) {
  var _b = _a, {
    store
  } = _b, props = __objRest(_b, [
    "store"
  ]);
  const [autoFocusOnHide, setAutoFocusOnHide] = (0, import_react5.useState)(false);
  const mounted = store.useState("mounted");
  (0, import_react5.useEffect)(() => {
    if (!mounted) {
      setAutoFocusOnHide(false);
    }
  }, [mounted]);
  const onFocusProp = props.onFocus;
  const onFocus = useEvent((event) => {
    onFocusProp == null ? void 0 : onFocusProp(event);
    if (event.defaultPrevented) return;
    setAutoFocusOnHide(true);
  });
  const finalFocusRef = (0, import_react5.useRef)(null);
  (0, import_react5.useEffect)(() => {
    return sync(store, ["anchorElement"], (state) => {
      finalFocusRef.current = state.anchorElement;
    });
  }, []);
  props = __spreadProps(__spreadValues({
    autoFocusOnHide,
    finalFocus: finalFocusRef
  }, props), {
    onFocus
  });
  return props;
}
var NestedHovercardContext = (0, import_react5.createContext)(null);
var useHovercard = createHook(
  function useHovercard2(_a) {
    var _b = _a, {
      store,
      modal = false,
      portal = !!modal,
      hideOnEscape = true,
      hideOnHoverOutside = true,
      disablePointerEventsOnApproach = !!hideOnHoverOutside
    } = _b, props = __objRest(_b, [
      "store",
      "modal",
      "portal",
      "hideOnEscape",
      "hideOnHoverOutside",
      "disablePointerEventsOnApproach"
    ]);
    const context = useHovercardProviderContext();
    store = store || context;
    invariant(
      store,
      process.env.NODE_ENV !== "production" && "Hovercard must receive a `store` prop or be wrapped in a HovercardProvider component."
    );
    const ref = (0, import_react5.useRef)(null);
    const [nestedHovercards, setNestedHovercards] = (0, import_react5.useState)([]);
    const hideTimeoutRef = (0, import_react5.useRef)(0);
    const enterPointRef = (0, import_react5.useRef)(null);
    const { portalRef, domReady } = usePortalRef(portal, props.portalRef);
    const isMouseMoving = useIsMouseMoving();
    const mayHideOnHoverOutside = !!hideOnHoverOutside;
    const hideOnHoverOutsideProp = useBooleanEvent(hideOnHoverOutside);
    const mayDisablePointerEvents = !!disablePointerEventsOnApproach;
    const disablePointerEventsProp = useBooleanEvent(
      disablePointerEventsOnApproach
    );
    const open = store.useState("open");
    const mounted = store.useState("mounted");
    (0, import_react5.useEffect)(() => {
      if (!domReady) return;
      if (!mounted) return;
      if (!mayHideOnHoverOutside && !mayDisablePointerEvents) return;
      const element = ref.current;
      if (!element) return;
      const onMouseMove = (event) => {
        if (!store) return;
        if (!isMouseMoving()) return;
        const { anchorElement, hideTimeout, timeout } = store.getState();
        const enterPoint = enterPointRef.current;
        const [target] = event.composedPath();
        const anchor = anchorElement;
        if (isMovingOnHovercard(target, element, anchor, nestedHovercards)) {
          enterPointRef.current = target && anchor && contains(anchor, target) ? getEventPoint(event) : null;
          window.clearTimeout(hideTimeoutRef.current);
          hideTimeoutRef.current = 0;
          return;
        }
        if (hideTimeoutRef.current) return;
        if (enterPoint) {
          const currentPoint = getEventPoint(event);
          const polygon = getElementPolygon(element, enterPoint);
          if (isPointInPolygon(currentPoint, polygon)) {
            enterPointRef.current = currentPoint;
            if (!disablePointerEventsProp(event)) return;
            event.preventDefault();
            event.stopPropagation();
            return;
          }
        }
        if (!hideOnHoverOutsideProp(event)) return;
        hideTimeoutRef.current = window.setTimeout(() => {
          hideTimeoutRef.current = 0;
          store == null ? void 0 : store.hide();
        }, hideTimeout != null ? hideTimeout : timeout);
      };
      return chain(
        addGlobalEventListener("mousemove", onMouseMove, true),
        () => clearTimeout(hideTimeoutRef.current)
      );
    }, [
      store,
      isMouseMoving,
      domReady,
      mounted,
      mayHideOnHoverOutside,
      mayDisablePointerEvents,
      nestedHovercards,
      disablePointerEventsProp,
      hideOnHoverOutsideProp
    ]);
    (0, import_react5.useEffect)(() => {
      if (!domReady) return;
      if (!mounted) return;
      if (!mayDisablePointerEvents) return;
      const disableEvent = (event) => {
        const element = ref.current;
        if (!element) return;
        const enterPoint = enterPointRef.current;
        if (!enterPoint) return;
        const polygon = getElementPolygon(element, enterPoint);
        if (isPointInPolygon(getEventPoint(event), polygon)) {
          if (!disablePointerEventsProp(event)) return;
          event.preventDefault();
          event.stopPropagation();
        }
      };
      return chain(
        // Note: we may need to add pointer events here in the future.
        addGlobalEventListener("mouseenter", disableEvent, true),
        addGlobalEventListener("mouseover", disableEvent, true),
        addGlobalEventListener("mouseout", disableEvent, true),
        addGlobalEventListener("mouseleave", disableEvent, true)
      );
    }, [domReady, mounted, mayDisablePointerEvents, disablePointerEventsProp]);
    (0, import_react5.useEffect)(() => {
      if (!domReady) return;
      if (open) return;
      store == null ? void 0 : store.setAutoFocusOnShow(false);
    }, [store, domReady, open]);
    const openRef = useLiveRef(open);
    (0, import_react5.useEffect)(() => {
      if (!domReady) return;
      return () => {
        if (!openRef.current) {
          store == null ? void 0 : store.setAutoFocusOnShow(false);
        }
      };
    }, [store, domReady]);
    const registerOnParent = (0, import_react5.useContext)(NestedHovercardContext);
    useSafeLayoutEffect(() => {
      if (modal) return;
      if (!portal) return;
      if (!mounted) return;
      if (!domReady) return;
      const element = ref.current;
      if (!element) return;
      return registerOnParent == null ? void 0 : registerOnParent(element);
    }, [modal, portal, mounted, domReady]);
    const registerNestedHovercard = (0, import_react5.useCallback)(
      (element) => {
        setNestedHovercards((prevElements) => [...prevElements, element]);
        const parentUnregister = registerOnParent == null ? void 0 : registerOnParent(element);
        return () => {
          setNestedHovercards(
            (prevElements) => prevElements.filter((item) => item !== element)
          );
          parentUnregister == null ? void 0 : parentUnregister();
        };
      },
      [registerOnParent]
    );
    props = useWrapElement(
      props,
      (element) => (0, import_jsx_runtime2.jsx)(HovercardScopedContextProvider, { value: store, children: (0, import_jsx_runtime2.jsx)(NestedHovercardContext.Provider, { value: registerNestedHovercard, children: element }) }),
      [store, registerNestedHovercard]
    );
    props = __spreadProps(__spreadValues({}, props), {
      ref: useMergeRefs(ref, props.ref)
    });
    props = useAutoFocusOnHide(__spreadValues({ store }, props));
    const autoFocusOnShow = store.useState(
      (state) => modal || state.autoFocusOnShow
    );
    props = usePopover(__spreadProps(__spreadValues({
      store,
      modal,
      portal,
      autoFocusOnShow
    }, props), {
      portalRef,
      hideOnEscape(event) {
        if (isFalsyBooleanCallback(hideOnEscape, event)) return false;
        requestAnimationFrame(() => {
          requestAnimationFrame(() => {
            store == null ? void 0 : store.hide();
          });
        });
        return true;
      }
    }));
    return props;
  }
);
var Hovercard = createDialogComponent(
  forwardRef2(function Hovercard2(props) {
    const htmlProps = useHovercard(props);
    return createElement(TagName2, htmlProps);
  }),
  useHovercardProviderContext
);

// ../node_modules/@ariakit/react-core/esm/menu/menu.js
var import_dist52 = __toESM(require_dist());
var import_dist53 = __toESM(require_dist2());
var import_dist54 = __toESM(require_dist3());
var import_react6 = __toESM(require_react());
var TagName3 = "div";
var useMenu = createHook(function useMenu2(_a) {
  var _b = _a, {
    store,
    modal: modalProp = false,
    portal = !!modalProp,
    hideOnEscape = true,
    autoFocusOnShow = true,
    hideOnHoverOutside,
    alwaysVisible
  } = _b, props = __objRest(_b, [
    "store",
    "modal",
    "portal",
    "hideOnEscape",
    "autoFocusOnShow",
    "hideOnHoverOutside",
    "alwaysVisible"
  ]);
  const context = useMenuProviderContext();
  store = store || context;
  invariant(
    store,
    process.env.NODE_ENV !== "production" && "Menu must receive a `store` prop or be wrapped in a MenuProvider component."
  );
  const ref = (0, import_react6.useRef)(null);
  const parentMenu = store.parent;
  const parentMenubar = store.menubar;
  const hasParentMenu = !!parentMenu;
  const parentIsMenubar = !!parentMenubar && !hasParentMenu;
  props = __spreadProps(__spreadValues({}, props), {
    ref: useMergeRefs(ref, props.ref)
  });
  const _a2 = useMenuList(__spreadValues({
    store,
    alwaysVisible
  }, props)), { "aria-labelledby": ariaLabelledBy } = _a2, menuListProps = __objRest(_a2, ["aria-labelledby"]);
  props = menuListProps;
  const [initialFocusRef, setInitialFocusRef] = (0, import_react6.useState)();
  const autoFocusOnShowState = store.useState("autoFocusOnShow");
  const initialFocus = store.useState("initialFocus");
  const baseElement = store.useState("baseElement");
  const items = store.useState("renderedItems");
  (0, import_react6.useEffect)(() => {
    let cleaning = false;
    setInitialFocusRef((prevInitialFocusRef) => {
      var _a3, _b2, _c;
      if (cleaning) return;
      if (!autoFocusOnShowState) return;
      if ((_a3 = prevInitialFocusRef == null ? void 0 : prevInitialFocusRef.current) == null ? void 0 : _a3.isConnected) return prevInitialFocusRef;
      const ref2 = (0, import_react6.createRef)();
      switch (initialFocus) {
        // TODO: Refactor
        case "first":
          ref2.current = ((_b2 = items.find((item) => !item.disabled && item.element)) == null ? void 0 : _b2.element) || null;
          break;
        case "last":
          ref2.current = ((_c = [...items].reverse().find((item) => !item.disabled && item.element)) == null ? void 0 : _c.element) || null;
          break;
        default:
          ref2.current = baseElement;
      }
      return ref2;
    });
    return () => {
      cleaning = true;
    };
  }, [store, autoFocusOnShowState, initialFocus, items, baseElement]);
  const modal = hasParentMenu ? false : modalProp;
  const mayAutoFocusOnShow = !!autoFocusOnShow;
  const canAutoFocusOnShow = !!initialFocusRef || !!props.initialFocus || !!modal;
  const contentElement = useStoreState(
    store.combobox || store,
    "contentElement"
  );
  const parentContentElement = useStoreState(
    (parentMenu == null ? void 0 : parentMenu.combobox) || parentMenu,
    "contentElement"
  );
  const preserveTabOrderAnchor = (0, import_react6.useMemo)(() => {
    if (!parentContentElement) return;
    if (!contentElement) return;
    const role = contentElement.getAttribute("role");
    const parentRole = parentContentElement.getAttribute("role");
    const parentIsMenuOrMenubar = parentRole === "menu" || parentRole === "menubar";
    if (parentIsMenuOrMenubar && role === "menu") return;
    return parentContentElement;
  }, [contentElement, parentContentElement]);
  if (preserveTabOrderAnchor !== void 0) {
    props = __spreadValues({
      preserveTabOrderAnchor
    }, props);
  }
  props = useHovercard(__spreadProps(__spreadValues({
    store,
    alwaysVisible,
    initialFocus: initialFocusRef,
    autoFocusOnShow: mayAutoFocusOnShow ? canAutoFocusOnShow && autoFocusOnShow : autoFocusOnShowState || !!modal
  }, props), {
    hideOnEscape(event) {
      if (isFalsyBooleanCallback(hideOnEscape, event)) return false;
      store == null ? void 0 : store.hideAll();
      return true;
    },
    hideOnHoverOutside(event) {
      const disclosureElement = store == null ? void 0 : store.getState().disclosureElement;
      const getHideOnHoverOutside = () => {
        if (typeof hideOnHoverOutside === "function") {
          return hideOnHoverOutside(event);
        }
        if (hideOnHoverOutside != null) return hideOnHoverOutside;
        if (hasParentMenu) return true;
        if (!parentIsMenubar) return false;
        if (!disclosureElement) return true;
        if (hasFocusWithin(disclosureElement)) return false;
        return true;
      };
      if (!getHideOnHoverOutside()) return false;
      if (event.defaultPrevented) return true;
      if (!hasParentMenu) return true;
      if (!disclosureElement) return true;
      fireEvent(disclosureElement, "mouseout", event);
      if (!hasFocusWithin(disclosureElement)) return true;
      requestAnimationFrame(() => {
        if (hasFocusWithin(disclosureElement)) return;
        store == null ? void 0 : store.hide();
      });
      return false;
    },
    modal,
    portal,
    backdrop: hasParentMenu ? false : props.backdrop
  }));
  props = __spreadValues({
    "aria-labelledby": ariaLabelledBy
  }, props);
  return props;
});
var Menu = createDialogComponent(
  forwardRef2(function Menu2(props) {
    const htmlProps = useMenu(props);
    return createElement(TagName3, htmlProps);
  }),
  useMenuProviderContext
);

// ../node_modules/@ariakit/react-core/esm/menu/menu-provider.js
var import_dist55 = __toESM(require_dist());
var import_dist56 = __toESM(require_dist2());
var import_dist57 = __toESM(require_dist3());
var import_jsx_runtime3 = __toESM(require_jsx_runtime());
function MenuProvider(props = {}) {
  const store = useMenuStore(props);
  return (0, import_jsx_runtime3.jsx)(MenuContextProvider, { value: store, children: props.children });
}

// ../node_modules/@ariakit/react-core/esm/__chunks/DZ7CBAYJ.js
var import_dist58 = __toESM(require_dist(), 1);
var import_dist59 = __toESM(require_dist2(), 1);
var import_dist60 = __toESM(require_dist3(), 1);
var import_jsx_runtime4 = __toESM(require_jsx_runtime(), 1);
var TagName4 = "div";
var useMenubar = createHook(
  function useMenubar2(_a) {
    var _b = _a, {
      store: storeProp,
      composite = true,
      orientation: orientationProp,
      virtualFocus,
      focusLoop,
      rtl
    } = _b, props = __objRest(_b, [
      "store",
      "composite",
      "orientation",
      "virtualFocus",
      "focusLoop",
      "rtl"
    ]);
    const context = useMenubarProviderContext();
    storeProp = storeProp || context;
    const store = useMenubarStore({
      store: storeProp,
      orientation: orientationProp,
      virtualFocus,
      focusLoop,
      rtl
    });
    const orientation = store.useState(
      (state) => !composite || state.orientation === "both" ? void 0 : state.orientation
    );
    props = useWrapElement(
      props,
      (element) => (0, import_jsx_runtime4.jsx)(MenubarScopedContextProvider, { value: store, children: element }),
      [store]
    );
    if (composite) {
      props = __spreadValues({
        role: "menubar",
        "aria-orientation": orientation
      }, props);
    }
    props = useComposite(__spreadValues({ store, composite }, props));
    return props;
  }
);
var Menubar = forwardRef2(function Menubar2(props) {
  const htmlProps = useMenubar(props);
  return createElement(TagName4, htmlProps);
});

// ../node_modules/@ariakit/react-core/esm/menu/menu-bar.js
var import_dist61 = __toESM(require_dist());
var import_dist62 = __toESM(require_dist2());
var import_dist63 = __toESM(require_dist3());
var import_react7 = __toESM(require_react());
var TagName5 = "div";
var useMenuBar = createHook(
  function useMenuBar2(props) {
    (0, import_react7.useEffect)(() => {
      if (process.env.NODE_ENV !== "production") {
        console.warn(
          "MenuBar is deprecated. Use Menubar instead.",
          "See https://ariakit.org/reference/menubar"
        );
      }
    }, []);
    return useMenubar(props);
  }
);
var MenuBar = forwardRef2(function MenuBar2(props) {
  const htmlProps = useMenuBar(props);
  return createElement(TagName5, htmlProps);
});

// ../node_modules/@ariakit/react-core/esm/__chunks/O5VVHQKK.js
var import_dist64 = __toESM(require_dist(), 1);
var import_dist65 = __toESM(require_dist2(), 1);
var import_dist66 = __toESM(require_dist3(), 1);
var import_jsx_runtime5 = __toESM(require_jsx_runtime(), 1);
function MenubarProvider(props = {}) {
  const store = useMenubarStore(props);
  return (0, import_jsx_runtime5.jsx)(MenubarContextProvider, { value: store, children: props.children });
}

// ../node_modules/@ariakit/react-core/esm/menu/menu-bar-provider.js
var import_dist67 = __toESM(require_dist());
var import_dist68 = __toESM(require_dist2());
var import_dist69 = __toESM(require_dist3());
var import_react8 = __toESM(require_react());
var import_jsx_runtime6 = __toESM(require_jsx_runtime());
function MenuBarProvider(props = {}) {
  (0, import_react8.useEffect)(() => {
    if (process.env.NODE_ENV !== "production") {
      console.warn(
        "MenuBarProvider is deprecated. Use MenubarProvider instead.",
        "See https://ariakit.org/reference/menubar-provider"
      );
    }
  }, []);
  return (0, import_jsx_runtime6.jsx)(MenubarProvider, __spreadValues({}, props));
}

// ../node_modules/@ariakit/react-core/esm/__chunks/VV5PQLL2.js
var import_dist73 = __toESM(require_dist(), 1);
var import_dist74 = __toESM(require_dist2(), 1);
var import_dist75 = __toESM(require_dist3(), 1);

// ../node_modules/@ariakit/react-core/esm/__chunks/2SM3RB2N.js
var import_dist70 = __toESM(require_dist(), 1);
var import_dist71 = __toESM(require_dist2(), 1);
var import_dist72 = __toESM(require_dist3(), 1);
var POPOVER_ARROW_PATH = "M23 27.8C24.1 29 26.4 30 28 30H30H0H2C3.7 30 5.9 29 7 27.8L14 20.6C14.7 19.8 15.3 19.8 16 20.6L23 27.8Z";

// ../node_modules/@ariakit/react-core/esm/__chunks/VV5PQLL2.js
var import_react9 = __toESM(require_react(), 1);
var import_jsx_runtime7 = __toESM(require_jsx_runtime(), 1);
var TagName6 = "div";
var defaultSize = 30;
var halfDefaultSize = defaultSize / 2;
var rotateMap = {
  top: `rotate(180 ${halfDefaultSize} ${halfDefaultSize})`,
  right: `rotate(-90 ${halfDefaultSize} ${halfDefaultSize})`,
  bottom: `rotate(0 ${halfDefaultSize} ${halfDefaultSize})`,
  left: `rotate(90 ${halfDefaultSize} ${halfDefaultSize})`
};
function useComputedStyle(store) {
  const [style, setStyle] = (0, import_react9.useState)();
  const contentElement = useStoreState(store, "contentElement");
  useSafeLayoutEffect(() => {
    if (!contentElement) return;
    const win = getWindow(contentElement);
    const computedStyle = win.getComputedStyle(contentElement);
    setStyle(computedStyle);
  }, [contentElement]);
  return style;
}
function getRingWidth(style) {
  var _a;
  if (!style) return;
  const boxShadow = style.getPropertyValue("box-shadow");
  const ringWidth = (_a = boxShadow.match(/0px 0px 0px ([^0]+px)/)) == null ? void 0 : _a[1];
  return ringWidth;
}
var usePopoverArrow = createHook(
  function usePopoverArrow2(_a) {
    var _b = _a, {
      store,
      size = defaultSize,
      borderWidth: borderWidthProp
    } = _b, props = __objRest(_b, [
      "store",
      "size",
      "borderWidth"
    ]);
    const context = usePopoverContext();
    store = store || context;
    invariant(
      store,
      process.env.NODE_ENV !== "production" && "PopoverArrow must be wrapped in a Popover component."
    );
    const dir = useStoreState(
      store,
      (state) => state.currentPlacement.split("-")[0]
    );
    const maskId = useId();
    const style = useComputedStyle(store);
    const fill = (style == null ? void 0 : style.getPropertyValue("background-color")) || "none";
    const stroke = (style == null ? void 0 : style.getPropertyValue(`border-${dir}-color`)) || "none";
    const borderWidth = (0, import_react9.useMemo)(() => {
      if (borderWidthProp != null) return borderWidthProp;
      if (!style) return 0;
      const ringWidth = getRingWidth(style);
      if (ringWidth) return Number.parseInt(ringWidth);
      const borderWidth2 = style.getPropertyValue(`border-${dir}-width`);
      if (borderWidth2) return Number.parseInt(borderWidth2);
      return 0;
    }, [borderWidthProp, style, dir]);
    const strokeWidth = borderWidth * 2 * (defaultSize / size);
    const transform = rotateMap[dir];
    const children = (0, import_react9.useMemo)(
      () => (0, import_jsx_runtime7.jsx)("svg", { display: "block", viewBox: "0 0 30 30", children: (0, import_jsx_runtime7.jsxs)("g", { transform, children: [
        (0, import_jsx_runtime7.jsx)("path", { fill: "none", d: POPOVER_ARROW_PATH, mask: `url(#${maskId})` }),
        (0, import_jsx_runtime7.jsx)("path", { stroke: "none", d: POPOVER_ARROW_PATH }),
        (0, import_jsx_runtime7.jsx)("mask", { id: maskId, maskUnits: "userSpaceOnUse", children: (0, import_jsx_runtime7.jsx)(
          "rect",
          {
            x: "-15",
            y: "0",
            width: "60",
            height: "30",
            fill: "white",
            stroke: "black"
          }
        ) })
      ] }) }),
      [transform, maskId]
    );
    props = __spreadProps(__spreadValues({
      children,
      "aria-hidden": true
    }, props), {
      ref: useMergeRefs(store.setArrowElement, props.ref),
      style: __spreadValues({
        position: "absolute",
        fontSize: size,
        width: "1em",
        height: "1em",
        pointerEvents: "none",
        fill: `var(--ak-layer, ${fill})`,
        stroke: `var(--ak-layer-border, ${stroke})`,
        strokeWidth
      }, props.style)
    });
    return removeUndefinedValues(props);
  }
);
var PopoverArrow = memo2(
  forwardRef2(function PopoverArrow2(props) {
    const htmlProps = usePopoverArrow(props);
    return createElement(TagName6, htmlProps);
  })
);

// ../node_modules/@ariakit/react-core/esm/menu/menu-arrow.js
var import_dist76 = __toESM(require_dist());
var import_dist77 = __toESM(require_dist2());
var import_dist78 = __toESM(require_dist3());
var TagName7 = "div";
var useMenuArrow = createHook(
  function useMenuArrow2(_a) {
    var _b = _a, { store } = _b, props = __objRest(_b, ["store"]);
    const context = useMenuContext();
    store = store || context;
    return usePopoverArrow(__spreadValues({ store }, props));
  }
);
var MenuArrow = forwardRef2(function MenuArrow2(props) {
  const htmlProps = useMenuArrow(props);
  return createElement(TagName7, htmlProps);
});

// ../node_modules/@ariakit/react-core/esm/menu/menu-button-arrow.js
var import_dist79 = __toESM(require_dist());
var import_dist80 = __toESM(require_dist2());
var import_dist81 = __toESM(require_dist3());
var TagName8 = "span";
var useMenuButtonArrow = createHook(
  function useMenuButtonArrow2(_a) {
    var _b = _a, { store } = _b, props = __objRest(_b, ["store"]);
    const context = useMenuContext();
    store = store || context;
    props = usePopoverDisclosureArrow(__spreadValues({ store }, props));
    return props;
  }
);
var MenuButtonArrow = forwardRef2(function MenuButtonArrow2(props) {
  const htmlProps = useMenuButtonArrow(props);
  return createElement(TagName8, htmlProps);
});

// ../node_modules/@ariakit/react-core/esm/__chunks/MR26YJYP.js
var import_dist82 = __toESM(require_dist(), 1);
var import_dist83 = __toESM(require_dist2(), 1);
var import_dist84 = __toESM(require_dist3(), 1);
var import_react10 = __toESM(require_react(), 1);
var TagName9 = "a";
var useHovercardAnchor = createHook(
  function useHovercardAnchor2(_a) {
    var _b = _a, { store, showOnHover = true } = _b, props = __objRest(_b, ["store", "showOnHover"]);
    const context = useHovercardProviderContext();
    store = store || context;
    invariant(
      store,
      process.env.NODE_ENV !== "production" && "HovercardAnchor must receive a `store` prop or be wrapped in a HovercardProvider component."
    );
    const disabled = disabledFromProps(props);
    const showTimeoutRef = (0, import_react10.useRef)(0);
    (0, import_react10.useEffect)(() => () => window.clearTimeout(showTimeoutRef.current), []);
    (0, import_react10.useEffect)(() => {
      const onMouseLeave = (event) => {
        if (!store) return;
        const { anchorElement } = store.getState();
        if (!anchorElement) return;
        if (event.target !== anchorElement) return;
        window.clearTimeout(showTimeoutRef.current);
        showTimeoutRef.current = 0;
      };
      return addGlobalEventListener("mouseleave", onMouseLeave, true);
    }, [store]);
    const onMouseMoveProp = props.onMouseMove;
    const showOnHoverProp = useBooleanEvent(showOnHover);
    const isMouseMoving = useIsMouseMoving();
    const onMouseMove = useEvent((event) => {
      onMouseMoveProp == null ? void 0 : onMouseMoveProp(event);
      if (disabled) return;
      if (!store) return;
      if (event.defaultPrevented) return;
      if (showTimeoutRef.current) return;
      if (!isMouseMoving()) return;
      if (!showOnHoverProp(event)) return;
      const element = event.currentTarget;
      store.setAnchorElement(element);
      store.setDisclosureElement(element);
      const { showTimeout, timeout } = store.getState();
      const showHovercard = () => {
        showTimeoutRef.current = 0;
        if (!isMouseMoving()) return;
        store == null ? void 0 : store.setAnchorElement(element);
        store == null ? void 0 : store.show();
        queueMicrotask(() => {
          store == null ? void 0 : store.setDisclosureElement(element);
        });
      };
      const timeoutMs = showTimeout != null ? showTimeout : timeout;
      if (timeoutMs === 0) {
        showHovercard();
      } else {
        showTimeoutRef.current = window.setTimeout(showHovercard, timeoutMs);
      }
    });
    const onClickProp = props.onClick;
    const onClick = useEvent((event) => {
      onClickProp == null ? void 0 : onClickProp(event);
      if (!store) return;
      window.clearTimeout(showTimeoutRef.current);
      showTimeoutRef.current = 0;
    });
    const ref = (0, import_react10.useCallback)(
      (element) => {
        if (!store) return;
        const { anchorElement } = store.getState();
        if (anchorElement == null ? void 0 : anchorElement.isConnected) return;
        store.setAnchorElement(element);
      },
      [store]
    );
    props = __spreadProps(__spreadValues({}, props), {
      ref: useMergeRefs(ref, props.ref),
      onMouseMove,
      onClick
    });
    props = useFocusable(props);
    return props;
  }
);
var HovercardAnchor = forwardRef2(function HovercardAnchor2(props) {
  const htmlProps = useHovercardAnchor(props);
  return createElement(TagName9, htmlProps);
});

// ../node_modules/@ariakit/react-core/esm/menu/menu-button.js
var import_dist85 = __toESM(require_dist());
var import_dist86 = __toESM(require_dist2());
var import_dist87 = __toESM(require_dist3());
var import_react11 = __toESM(require_react());
var import_jsx_runtime8 = __toESM(require_jsx_runtime());
var TagName10 = "button";
function getInitialFocus(event, dir) {
  const keyMap = {
    ArrowDown: dir === "bottom" || dir === "top" ? "first" : false,
    ArrowUp: dir === "bottom" || dir === "top" ? "last" : false,
    ArrowRight: dir === "right" ? "first" : false,
    ArrowLeft: dir === "left" ? "first" : false
  };
  return keyMap[event.key];
}
function hasActiveItem(items, excludeElement) {
  return !!(items == null ? void 0 : items.some((item) => {
    if (!item.element) return false;
    if (item.element === excludeElement) return false;
    return item.element.getAttribute("aria-expanded") === "true";
  }));
}
var useMenuButton = createHook(
  function useMenuButton2(_a) {
    var _b = _a, {
      store,
      focusable,
      accessibleWhenDisabled,
      showOnHover
    } = _b, props = __objRest(_b, [
      "store",
      "focusable",
      "accessibleWhenDisabled",
      "showOnHover"
    ]);
    const context = useMenuProviderContext();
    store = store || context;
    invariant(
      store,
      process.env.NODE_ENV !== "production" && "MenuButton must receive a `store` prop or be wrapped in a MenuProvider component."
    );
    const ref = (0, import_react11.useRef)(null);
    const parentMenu = store.parent;
    const parentMenubar = store.menubar;
    const hasParentMenu = !!parentMenu;
    const parentIsMenubar = !!parentMenubar && !hasParentMenu;
    const disabled = disabledFromProps(props);
    const showMenu = () => {
      const trigger = ref.current;
      if (!trigger) return;
      store == null ? void 0 : store.setDisclosureElement(trigger);
      store == null ? void 0 : store.setAnchorElement(trigger);
      store == null ? void 0 : store.show();
    };
    const onFocusProp = props.onFocus;
    const onFocus = useEvent((event) => {
      onFocusProp == null ? void 0 : onFocusProp(event);
      if (disabled) return;
      if (event.defaultPrevented) return;
      store == null ? void 0 : store.setAutoFocusOnShow(false);
      store == null ? void 0 : store.setActiveId(null);
      if (!parentMenubar) return;
      if (!parentIsMenubar) return;
      const { items } = parentMenubar.getState();
      if (hasActiveItem(items, event.currentTarget)) {
        showMenu();
      }
    });
    const dir = useStoreState(
      store,
      (state) => state.placement.split("-")[0]
    );
    const onKeyDownProp = props.onKeyDown;
    const onKeyDown = useEvent((event) => {
      onKeyDownProp == null ? void 0 : onKeyDownProp(event);
      if (disabled) return;
      if (event.defaultPrevented) return;
      const initialFocus = getInitialFocus(event, dir);
      if (initialFocus) {
        event.preventDefault();
        showMenu();
        store == null ? void 0 : store.setAutoFocusOnShow(true);
        store == null ? void 0 : store.setInitialFocus(initialFocus);
      }
    });
    const onClickProp = props.onClick;
    const onClick = useEvent((event) => {
      onClickProp == null ? void 0 : onClickProp(event);
      if (event.defaultPrevented) return;
      if (!store) return;
      const isKeyboardClick = !event.detail;
      const { open } = store.getState();
      if (!open || isKeyboardClick) {
        if (!hasParentMenu || isKeyboardClick) {
          store.setAutoFocusOnShow(true);
        }
        store.setInitialFocus(isKeyboardClick ? "first" : "container");
      }
      if (hasParentMenu) {
        showMenu();
      }
    });
    props = useWrapElement(
      props,
      (element) => (0, import_jsx_runtime8.jsx)(MenuContextProvider, { value: store, children: element }),
      [store]
    );
    if (hasParentMenu) {
      props = __spreadProps(__spreadValues({}, props), {
        render: (0, import_jsx_runtime8.jsx)(Role.div, { render: props.render })
      });
    }
    const id = useId(props.id);
    const parentContentElement = useStoreState(
      (parentMenu == null ? void 0 : parentMenu.combobox) || parentMenu,
      "contentElement"
    );
    const role = hasParentMenu || parentIsMenubar ? getPopupItemRole(parentContentElement, "menuitem") : void 0;
    const contentElement = store.useState("contentElement");
    props = __spreadProps(__spreadValues({
      id,
      role,
      "aria-haspopup": getPopupRole(contentElement, "menu")
    }, props), {
      ref: useMergeRefs(ref, props.ref),
      onFocus,
      onKeyDown,
      onClick
    });
    props = useHovercardAnchor(__spreadProps(__spreadValues({
      store,
      focusable,
      accessibleWhenDisabled
    }, props), {
      showOnHover: (event) => {
        const getShowOnHover = () => {
          if (typeof showOnHover === "function") return showOnHover(event);
          if (showOnHover != null) return showOnHover;
          if (hasParentMenu) return true;
          if (!parentMenubar) return false;
          const { items } = parentMenubar.getState();
          return parentIsMenubar && hasActiveItem(items);
        };
        const canShowOnHover = getShowOnHover();
        if (!canShowOnHover) return false;
        const parent = parentIsMenubar ? parentMenubar : parentMenu;
        if (!parent) return true;
        parent.setActiveId(event.currentTarget.id);
        return true;
      }
    }));
    props = usePopoverDisclosure(__spreadValues({
      store,
      toggleOnClick: !hasParentMenu,
      focusable,
      accessibleWhenDisabled
    }, props));
    props = useCompositeTypeahead(__spreadValues({
      store,
      typeahead: parentIsMenubar
    }, props));
    return props;
  }
);
var MenuButton = forwardRef2(function MenuButton2(props) {
  const htmlProps = useMenuButton(props);
  return createElement(TagName10, htmlProps);
});

// ../node_modules/@ariakit/react-core/esm/__chunks/GNXFPHGE.js
var import_dist88 = __toESM(require_dist(), 1);
var import_dist89 = __toESM(require_dist2(), 1);
var import_dist90 = __toESM(require_dist3(), 1);
var import_react12 = __toESM(require_react(), 1);
var TagName11 = "p";
var useDialogDescription = createHook(function useDialogDescription2(_a) {
  var _b = _a, { store } = _b, props = __objRest(_b, ["store"]);
  const setDescriptionId = (0, import_react12.useContext)(DialogDescriptionContext);
  const id = useId(props.id);
  useSafeLayoutEffect(() => {
    setDescriptionId == null ? void 0 : setDescriptionId(id);
    return () => setDescriptionId == null ? void 0 : setDescriptionId(void 0);
  }, [setDescriptionId, id]);
  props = __spreadValues({
    id
  }, props);
  return removeUndefinedValues(props);
});
var DialogDescription = forwardRef2(function DialogDescription2(props) {
  const htmlProps = useDialogDescription(props);
  return createElement(TagName11, htmlProps);
});

// ../node_modules/@ariakit/react-core/esm/__chunks/343LYRPB.js
var import_dist91 = __toESM(require_dist(), 1);
var import_dist92 = __toESM(require_dist2(), 1);
var import_dist93 = __toESM(require_dist3(), 1);
var TagName12 = "p";
var usePopoverDescription = createHook(function usePopoverDescription2(props) {
  props = useDialogDescription(props);
  return props;
});
var PopoverDescription = forwardRef2(function PopoverDescription2(props) {
  const htmlProps = usePopoverDescription(props);
  return createElement(TagName12, htmlProps);
});

// ../node_modules/@ariakit/react-core/esm/__chunks/I22EHHZ4.js
var import_dist94 = __toESM(require_dist(), 1);
var import_dist95 = __toESM(require_dist2(), 1);
var import_dist96 = __toESM(require_dist3(), 1);
var TagName13 = "p";
var useHovercardDescription = createHook(function useHovercardDescription2(props) {
  props = usePopoverDescription(props);
  return props;
});
var HovercardDescription = forwardRef2(function HovercardDescription2(props) {
  const htmlProps = useHovercardDescription(props);
  return createElement(TagName13, htmlProps);
});

// ../node_modules/@ariakit/react-core/esm/menu/menu-description.js
var import_dist97 = __toESM(require_dist());
var import_dist98 = __toESM(require_dist2());
var import_dist99 = __toESM(require_dist3());
var TagName14 = "p";
var useMenuDescription = createHook(
  function useMenuDescription2(props) {
    props = useHovercardDescription(props);
    return props;
  }
);
var MenuDescription = forwardRef2(function MenuDescription2(props) {
  const htmlProps = useMenuDescription(props);
  return createElement(TagName14, htmlProps);
});

// ../node_modules/@ariakit/react-core/esm/__chunks/T4ZQV3MD.js
var import_dist100 = __toESM(require_dist(), 1);
var import_dist101 = __toESM(require_dist2(), 1);
var import_dist102 = __toESM(require_dist3(), 1);
var TagName15 = "button";
var useHovercardDismiss = createHook(
  function useHovercardDismiss2(_a) {
    var _b = _a, { store } = _b, props = __objRest(_b, ["store"]);
    const context = useHovercardScopedContext();
    store = store || context;
    props = usePopoverDismiss(__spreadValues({ store }, props));
    return props;
  }
);
var HovercardDismiss = forwardRef2(function HovercardDismiss2(props) {
  const htmlProps = useHovercardDismiss(props);
  return createElement(TagName15, htmlProps);
});

// ../node_modules/@ariakit/react-core/esm/menu/menu-dismiss.js
var import_dist103 = __toESM(require_dist());
var import_dist104 = __toESM(require_dist2());
var import_dist105 = __toESM(require_dist3());
var TagName16 = "button";
var useMenuDismiss = createHook(
  function useMenuDismiss2(_a) {
    var _b = _a, { store } = _b, props = __objRest(_b, ["store"]);
    const context = useMenuScopedContext();
    store = store || context;
    props = useHovercardDismiss(__spreadValues({ store }, props));
    return props;
  }
);
var MenuDismiss = forwardRef2(function MenuDismiss2(props) {
  const htmlProps = useMenuDismiss(props);
  return createElement(TagName16, htmlProps);
});

// ../node_modules/@ariakit/react-core/esm/menu/menu-group-label.js
var import_dist106 = __toESM(require_dist());
var import_dist107 = __toESM(require_dist2());
var import_dist108 = __toESM(require_dist3());
var TagName17 = "div";
var useMenuGroupLabel = createHook(
  function useMenuGroupLabel2(props) {
    props = useCompositeGroupLabel(props);
    return props;
  }
);
var MenuGroupLabel = forwardRef2(function MenuGroupLabel2(props) {
  const htmlProps = useMenuGroupLabel(props);
  return createElement(TagName17, htmlProps);
});

// ../node_modules/@ariakit/react-core/esm/menu/menu-group.js
var import_dist109 = __toESM(require_dist());
var import_dist110 = __toESM(require_dist2());
var import_dist111 = __toESM(require_dist3());
var TagName18 = "div";
var useMenuGroup = createHook(
  function useMenuGroup2(props) {
    props = useCompositeGroup(props);
    return props;
  }
);
var MenuGroup = forwardRef2(function MenuGroup2(props) {
  const htmlProps = useMenuGroup(props);
  return createElement(TagName18, htmlProps);
});

// ../node_modules/@ariakit/react-core/esm/__chunks/6MFI6SZM.js
var import_dist112 = __toESM(require_dist(), 1);
var import_dist113 = __toESM(require_dist2(), 1);
var import_dist114 = __toESM(require_dist3(), 1);
var TagName19 = "h1";
var useHovercardHeading = createHook(
  function useHovercardHeading2(props) {
    props = usePopoverHeading(props);
    return props;
  }
);
var HovercardHeading = forwardRef2(function HovercardHeading2(props) {
  const htmlProps = useHovercardHeading(props);
  return createElement(TagName19, htmlProps);
});

// ../node_modules/@ariakit/react-core/esm/menu/menu-heading.js
var import_dist115 = __toESM(require_dist());
var import_dist116 = __toESM(require_dist2());
var import_dist117 = __toESM(require_dist3());
var TagName20 = "h1";
var useMenuHeading = createHook(
  function useMenuHeading2(props) {
    props = useHovercardHeading(props);
    return props;
  }
);
var MenuHeading = forwardRef2(function MenuHeading2(props) {
  const htmlProps = useMenuHeading(props);
  return createElement(TagName20, htmlProps);
});

// ../node_modules/@ariakit/react-core/esm/menu/menu-item-check.js
var import_dist118 = __toESM(require_dist());
var import_dist119 = __toESM(require_dist2());
var import_dist120 = __toESM(require_dist3());
var import_react13 = __toESM(require_react());
var TagName21 = "span";
var useMenuItemCheck = createHook(
  function useMenuItemCheck2(_a) {
    var _b = _a, { store, checked } = _b, props = __objRest(_b, ["store", "checked"]);
    const context = (0, import_react13.useContext)(MenuItemCheckedContext2);
    checked = checked != null ? checked : context;
    props = useCheckboxCheck(__spreadProps(__spreadValues({}, props), { checked }));
    return props;
  }
);
var MenuItemCheck = forwardRef2(function MenuItemCheck2(props) {
  const htmlProps = useMenuItemCheck(props);
  return createElement(TagName21, htmlProps);
});

// ../node_modules/@ariakit/react-core/esm/__chunks/2NBKRL7C.js
var import_dist121 = __toESM(require_dist(), 1);
var import_dist122 = __toESM(require_dist2(), 1);
var import_dist123 = __toESM(require_dist3(), 1);
var TagName22 = "div";
function menuHasFocus(baseElement, items, currentTarget) {
  var _a;
  if (!baseElement) return false;
  if (hasFocusWithin(baseElement)) return true;
  const expandedItem = items == null ? void 0 : items.find((item) => {
    var _a2;
    if (item.element === currentTarget) return false;
    return ((_a2 = item.element) == null ? void 0 : _a2.getAttribute("aria-expanded")) === "true";
  });
  const expandedMenuId = (_a = expandedItem == null ? void 0 : expandedItem.element) == null ? void 0 : _a.getAttribute("aria-controls");
  if (!expandedMenuId) return false;
  const doc = getDocument(baseElement);
  const expandedMenu = doc.getElementById(expandedMenuId);
  if (!expandedMenu) return false;
  if (hasFocusWithin(expandedMenu)) return true;
  return !!expandedMenu.querySelector("[role=menuitem][aria-expanded=true]");
}
var useMenuItem = createHook(
  function useMenuItem2(_a) {
    var _b = _a, {
      store,
      hideOnClick = true,
      preventScrollOnKeyDown = true,
      focusOnHover,
      blurOnHoverEnd
    } = _b, props = __objRest(_b, [
      "store",
      "hideOnClick",
      "preventScrollOnKeyDown",
      "focusOnHover",
      "blurOnHoverEnd"
    ]);
    const menuContext = useMenuScopedContext(true);
    const menubarContext = useMenubarScopedContext();
    store = store || menuContext || menubarContext;
    invariant(
      store,
      process.env.NODE_ENV !== "production" && "MenuItem must be wrapped in a MenuList, Menu or Menubar component"
    );
    const onClickProp = props.onClick;
    const hideOnClickProp = useBooleanEvent(hideOnClick);
    const hideMenu = "hideAll" in store ? store.hideAll : void 0;
    const isWithinMenu = !!hideMenu;
    const onClick = useEvent((event) => {
      onClickProp == null ? void 0 : onClickProp(event);
      if (event.defaultPrevented) return;
      if (isDownloading(event)) return;
      if (isOpeningInNewTab(event)) return;
      if (!hideMenu) return;
      const popupType = event.currentTarget.getAttribute("aria-haspopup");
      if (popupType === "menu") return;
      if (!hideOnClickProp(event)) return;
      hideMenu();
    });
    const contentElement = useStoreState(
      store,
      (state) => "contentElement" in state ? state.contentElement : null
    );
    const role = getPopupItemRole(contentElement, "menuitem");
    props = __spreadProps(__spreadValues({
      role
    }, props), {
      onClick
    });
    props = useCompositeItem(__spreadValues({
      store,
      preventScrollOnKeyDown
    }, props));
    props = useCompositeHover(__spreadProps(__spreadValues({
      store
    }, props), {
      focusOnHover(event) {
        const getFocusOnHover = () => {
          if (typeof focusOnHover === "function") return focusOnHover(event);
          if (focusOnHover != null) return focusOnHover;
          return true;
        };
        if (!store) return false;
        if (!getFocusOnHover()) return false;
        const { baseElement, items } = store.getState();
        if (isWithinMenu) {
          if (event.currentTarget.hasAttribute("aria-expanded")) {
            event.currentTarget.focus();
          }
          return true;
        }
        if (menuHasFocus(baseElement, items, event.currentTarget)) {
          event.currentTarget.focus();
          return true;
        }
        return false;
      },
      blurOnHoverEnd(event) {
        if (typeof blurOnHoverEnd === "function") return blurOnHoverEnd(event);
        if (blurOnHoverEnd != null) return blurOnHoverEnd;
        return isWithinMenu;
      }
    }));
    return props;
  }
);
var MenuItem = memo2(
  forwardRef2(function MenuItem2(props) {
    const htmlProps = useMenuItem(props);
    return createElement(TagName22, htmlProps);
  })
);

// ../node_modules/@ariakit/react-core/esm/__chunks/HAVBGUA3.js
var import_dist127 = __toESM(require_dist(), 1);
var import_dist128 = __toESM(require_dist2(), 1);
var import_dist129 = __toESM(require_dist3(), 1);

// ../node_modules/@ariakit/core/esm/checkbox/checkbox-store.js
var import_dist124 = __toESM(require_dist());
var import_dist125 = __toESM(require_dist2());
var import_dist126 = __toESM(require_dist3());
function createCheckboxStore(props = {}) {
  var _a;
  throwOnConflictingProps(props, props.store);
  const syncState = (_a = props.store) == null ? void 0 : _a.getState();
  const initialState = {
    value: defaultValue(
      props.value,
      syncState == null ? void 0 : syncState.value,
      props.defaultValue,
      false
    )
  };
  const checkbox = createStore(initialState, props.store);
  return __spreadProps2(__spreadValues2({}, checkbox), {
    setValue: (value) => checkbox.setState("value", value)
  });
}

// ../node_modules/@ariakit/react-core/esm/__chunks/HAVBGUA3.js
function useCheckboxStoreProps(store, update, props) {
  useUpdateEffect(update, [props.store]);
  useStoreProps(store, props, "value", "setValue");
  return store;
}
function useCheckboxStore(props = {}) {
  const [store, update] = useStore(createCheckboxStore, props);
  return useCheckboxStoreProps(store, update, props);
}

// ../node_modules/@ariakit/react-core/esm/__chunks/RNCDFVMF.js
var import_dist130 = __toESM(require_dist(), 1);
var import_dist131 = __toESM(require_dist2(), 1);
var import_dist132 = __toESM(require_dist3(), 1);
var ctx2 = createStoreContext();
var useCheckboxContext = ctx2.useContext;
var useCheckboxScopedContext = ctx2.useScopedContext;
var useCheckboxProviderContext = ctx2.useProviderContext;
var CheckboxContextProvider = ctx2.ContextProvider;
var CheckboxScopedContextProvider = ctx2.ScopedContextProvider;

// ../node_modules/@ariakit/react-core/esm/__chunks/IAEAQUOT.js
var import_dist133 = __toESM(require_dist(), 1);
var import_dist134 = __toESM(require_dist2(), 1);
var import_dist135 = __toESM(require_dist3(), 1);
var import_react14 = __toESM(require_react(), 1);
var import_jsx_runtime9 = __toESM(require_jsx_runtime(), 1);
var TagName23 = "input";
function setMixed(element, mixed) {
  if (mixed) {
    element.indeterminate = true;
  } else if (element.indeterminate) {
    element.indeterminate = false;
  }
}
function isNativeCheckbox(tagName, type) {
  return tagName === "input" && (!type || type === "checkbox");
}
function getPrimitiveValue(value) {
  if (Array.isArray(value)) {
    return value.toString();
  }
  return value;
}
var useCheckbox = createHook(
  function useCheckbox2(_a) {
    var _b = _a, {
      store,
      name,
      value: valueProp,
      checked: checkedProp,
      defaultChecked
    } = _b, props = __objRest(_b, [
      "store",
      "name",
      "value",
      "checked",
      "defaultChecked"
    ]);
    const context = useCheckboxContext();
    store = store || context;
    const [_checked, setChecked] = (0, import_react14.useState)(defaultChecked != null ? defaultChecked : false);
    const checked = useStoreState(store, (state) => {
      if (checkedProp !== void 0) return checkedProp;
      if ((state == null ? void 0 : state.value) === void 0) return _checked;
      if (valueProp != null) {
        if (Array.isArray(state.value)) {
          const primitiveValue = getPrimitiveValue(valueProp);
          return state.value.includes(primitiveValue);
        }
        return state.value === valueProp;
      }
      if (Array.isArray(state.value)) return false;
      if (typeof state.value === "boolean") return state.value;
      return false;
    });
    const ref = (0, import_react14.useRef)(null);
    const tagName = useTagName(ref, TagName23);
    const nativeCheckbox = isNativeCheckbox(tagName, props.type);
    const mixed = checked ? checked === "mixed" : void 0;
    const isChecked = checked === "mixed" ? false : checked;
    const disabled = disabledFromProps(props);
    const [propertyUpdated, schedulePropertyUpdate] = useForceUpdate();
    (0, import_react14.useEffect)(() => {
      const element = ref.current;
      if (!element) return;
      setMixed(element, mixed);
      if (nativeCheckbox) return;
      element.checked = isChecked;
      if (name !== void 0) {
        element.name = name;
      }
      if (valueProp !== void 0) {
        element.value = `${valueProp}`;
      }
    }, [propertyUpdated, mixed, nativeCheckbox, isChecked, name, valueProp]);
    const onChangeProp = props.onChange;
    const onChange = useEvent((event) => {
      if (disabled) {
        event.stopPropagation();
        event.preventDefault();
        return;
      }
      setMixed(event.currentTarget, mixed);
      if (!nativeCheckbox) {
        event.currentTarget.checked = !event.currentTarget.checked;
        schedulePropertyUpdate();
      }
      onChangeProp == null ? void 0 : onChangeProp(event);
      if (event.defaultPrevented) return;
      const elementChecked = event.currentTarget.checked;
      setChecked(elementChecked);
      store == null ? void 0 : store.setValue((prevValue) => {
        if (valueProp == null) return elementChecked;
        const primitiveValue = getPrimitiveValue(valueProp);
        if (!Array.isArray(prevValue)) {
          return prevValue === primitiveValue ? false : primitiveValue;
        }
        if (elementChecked) {
          if (prevValue.includes(primitiveValue)) {
            return prevValue;
          }
          return [...prevValue, primitiveValue];
        }
        return prevValue.filter((v) => v !== primitiveValue);
      });
    });
    const onClickProp = props.onClick;
    const onClick = useEvent((event) => {
      onClickProp == null ? void 0 : onClickProp(event);
      if (event.defaultPrevented) return;
      if (nativeCheckbox) return;
      onChange(event);
    });
    props = useWrapElement(
      props,
      (element) => (0, import_jsx_runtime9.jsx)(CheckboxCheckedContext.Provider, { value: isChecked, children: element }),
      [isChecked]
    );
    props = __spreadProps(__spreadValues({
      role: !nativeCheckbox ? "checkbox" : void 0,
      type: nativeCheckbox ? "checkbox" : void 0,
      "aria-checked": checked
    }, props), {
      ref: useMergeRefs(ref, props.ref),
      onChange,
      onClick
    });
    props = useCommand(__spreadValues({ clickOnEnter: !nativeCheckbox }, props));
    return removeUndefinedValues(__spreadValues({
      name: nativeCheckbox ? name : void 0,
      value: nativeCheckbox ? valueProp : void 0,
      checked: isChecked
    }, props));
  }
);
var Checkbox = forwardRef2(function Checkbox2(props) {
  const htmlProps = useCheckbox(props);
  return createElement(TagName23, htmlProps);
});

// ../node_modules/@ariakit/react-core/esm/menu/menu-item-checkbox.js
var import_dist136 = __toESM(require_dist());
var import_dist137 = __toESM(require_dist2());
var import_dist138 = __toESM(require_dist3());
var import_react15 = __toESM(require_react());
var TagName24 = "div";
function getPrimitiveValue2(value) {
  if (Array.isArray(value)) {
    return value.toString();
  }
  return value;
}
function getValue(storeValue, value, checked) {
  if (value === void 0) {
    if (Array.isArray(storeValue)) return storeValue;
    return !!checked;
  }
  const primitiveValue = getPrimitiveValue2(value);
  if (!Array.isArray(storeValue)) {
    if (checked) {
      return primitiveValue;
    }
    return storeValue === primitiveValue ? false : storeValue;
  }
  if (checked) {
    if (storeValue.includes(primitiveValue)) {
      return storeValue;
    }
    return [...storeValue, primitiveValue];
  }
  return storeValue.filter((v) => v !== primitiveValue);
}
var useMenuItemCheckbox = createHook(
  function useMenuItemCheckbox2(_a) {
    var _b = _a, {
      store,
      name,
      value,
      checked,
      defaultChecked: defaultCheckedProp,
      hideOnClick = false
    } = _b, props = __objRest(_b, [
      "store",
      "name",
      "value",
      "checked",
      "defaultChecked",
      "hideOnClick"
    ]);
    const context = useMenuScopedContext();
    store = store || context;
    invariant(
      store,
      process.env.NODE_ENV !== "production" && "MenuItemCheckbox must be wrapped in a MenuList or Menu component"
    );
    const defaultChecked = useInitialValue(defaultCheckedProp);
    (0, import_react15.useEffect)(() => {
      store == null ? void 0 : store.setValue(name, (prevValue = []) => {
        if (!defaultChecked) return prevValue;
        return getValue(prevValue, value, true);
      });
    }, [store, name, value, defaultChecked]);
    (0, import_react15.useEffect)(() => {
      if (checked === void 0) return;
      store == null ? void 0 : store.setValue(name, (prevValue) => {
        return getValue(prevValue, value, checked);
      });
    }, [store, name, value, checked]);
    const checkboxStore = useCheckboxStore({
      value: store.useState((state) => state.values[name]),
      setValue(internalValue) {
        store == null ? void 0 : store.setValue(name, () => {
          if (checked === void 0) return internalValue;
          const nextValue = getValue(internalValue, value, checked);
          if (!Array.isArray(nextValue)) return nextValue;
          if (!Array.isArray(internalValue)) return nextValue;
          if (shallowEqual(internalValue, nextValue)) return internalValue;
          return nextValue;
        });
      }
    });
    props = __spreadValues({
      role: "menuitemcheckbox"
    }, props);
    props = useCheckbox(__spreadValues({
      store: checkboxStore,
      name,
      value,
      checked
    }, props));
    props = useMenuItem(__spreadValues({ store, hideOnClick }, props));
    return props;
  }
);
var MenuItemCheckbox = memo2(
  forwardRef2(function MenuItemCheckbox2(props) {
    const htmlProps = useMenuItemCheckbox(props);
    return createElement(TagName24, htmlProps);
  })
);

// ../node_modules/@ariakit/react-core/esm/__chunks/UVUMR3WP.js
var import_dist139 = __toESM(require_dist(), 1);
var import_dist140 = __toESM(require_dist2(), 1);
var import_dist141 = __toESM(require_dist3(), 1);
var ctx3 = createStoreContext(
  [CompositeContextProvider],
  [CompositeScopedContextProvider]
);
var useRadioContext = ctx3.useContext;
var useRadioScopedContext = ctx3.useScopedContext;
var useRadioProviderContext = ctx3.useProviderContext;
var RadioContextProvider = ctx3.ContextProvider;
var RadioScopedContextProvider = ctx3.ScopedContextProvider;

// ../node_modules/@ariakit/react-core/esm/__chunks/AVVE7UTR.js
var import_dist142 = __toESM(require_dist(), 1);
var import_dist143 = __toESM(require_dist2(), 1);
var import_dist144 = __toESM(require_dist3(), 1);
var import_react16 = __toESM(require_react(), 1);
var TagName25 = "input";
function getIsChecked(value, storeValue) {
  if (storeValue === void 0) return;
  if (value != null && storeValue != null) {
    return storeValue === value;
  }
  return !!storeValue;
}
function isNativeRadio(tagName, type) {
  return tagName === "input" && (!type || type === "radio");
}
var useRadio = createHook(function useRadio2(_a) {
  var _b = _a, {
    store,
    name,
    value,
    checked
  } = _b, props = __objRest(_b, [
    "store",
    "name",
    "value",
    "checked"
  ]);
  const context = useRadioContext();
  store = store || context;
  const id = useId(props.id);
  const ref = (0, import_react16.useRef)(null);
  const isChecked = useStoreState(
    store,
    (state) => checked != null ? checked : getIsChecked(value, state == null ? void 0 : state.value)
  );
  (0, import_react16.useEffect)(() => {
    if (!id) return;
    if (!isChecked) return;
    const isActiveItem = (store == null ? void 0 : store.getState().activeId) === id;
    if (isActiveItem) return;
    store == null ? void 0 : store.setActiveId(id);
  }, [store, isChecked, id]);
  const onChangeProp = props.onChange;
  const tagName = useTagName(ref, TagName25);
  const nativeRadio = isNativeRadio(tagName, props.type);
  const disabled = disabledFromProps(props);
  const [propertyUpdated, schedulePropertyUpdate] = useForceUpdate();
  (0, import_react16.useEffect)(() => {
    const element = ref.current;
    if (!element) return;
    if (nativeRadio) return;
    if (isChecked !== void 0) {
      element.checked = isChecked;
    }
    if (name !== void 0) {
      element.name = name;
    }
    if (value !== void 0) {
      element.value = `${value}`;
    }
  }, [propertyUpdated, nativeRadio, isChecked, name, value]);
  const onChange = useEvent((event) => {
    if (disabled) {
      event.preventDefault();
      event.stopPropagation();
      return;
    }
    if ((store == null ? void 0 : store.getState().value) === value) return;
    if (!nativeRadio) {
      event.currentTarget.checked = true;
      schedulePropertyUpdate();
    }
    onChangeProp == null ? void 0 : onChangeProp(event);
    if (event.defaultPrevented) return;
    store == null ? void 0 : store.setValue(value);
  });
  const onClickProp = props.onClick;
  const onClick = useEvent((event) => {
    onClickProp == null ? void 0 : onClickProp(event);
    if (event.defaultPrevented) return;
    if (nativeRadio) return;
    onChange(event);
  });
  const onFocusProp = props.onFocus;
  const onFocus = useEvent((event) => {
    onFocusProp == null ? void 0 : onFocusProp(event);
    if (event.defaultPrevented) return;
    if (!nativeRadio) return;
    if (!store) return;
    const { moves, activeId } = store.getState();
    if (!moves) return;
    if (id && activeId !== id) return;
    onChange(event);
  });
  props = __spreadProps(__spreadValues({
    id,
    role: !nativeRadio ? "radio" : void 0,
    type: nativeRadio ? "radio" : void 0,
    "aria-checked": isChecked
  }, props), {
    ref: useMergeRefs(ref, props.ref),
    onChange,
    onClick,
    onFocus
  });
  props = useCompositeItem(__spreadValues({
    store,
    clickOnEnter: !nativeRadio
  }, props));
  return removeUndefinedValues(__spreadValues({
    name: nativeRadio ? name : void 0,
    value: nativeRadio ? value : void 0,
    checked: isChecked
  }, props));
});
var Radio = memo2(
  forwardRef2(function Radio2(props) {
    const htmlProps = useRadio(props);
    return createElement(TagName25, htmlProps);
  })
);

// ../node_modules/@ariakit/react-core/esm/menu/menu-item-radio.js
var import_dist145 = __toESM(require_dist());
var import_dist146 = __toESM(require_dist2());
var import_dist147 = __toESM(require_dist3());
var import_react17 = __toESM(require_react());
var import_jsx_runtime10 = __toESM(require_jsx_runtime());
var TagName26 = "div";
function getValue2(prevValue, value, checked) {
  if (checked === void 0) return prevValue;
  if (checked) return value;
  return prevValue;
}
var useMenuItemRadio = createHook(
  function useMenuItemRadio2(_a) {
    var _b = _a, {
      store,
      name,
      value,
      checked,
      onChange: onChangeProp,
      hideOnClick = false
    } = _b, props = __objRest(_b, [
      "store",
      "name",
      "value",
      "checked",
      "onChange",
      "hideOnClick"
    ]);
    const context = useMenuScopedContext();
    store = store || context;
    invariant(
      store,
      process.env.NODE_ENV !== "production" && "MenuItemRadio must be wrapped in a MenuList or Menu component"
    );
    const defaultChecked = useInitialValue(props.defaultChecked);
    (0, import_react17.useEffect)(() => {
      store == null ? void 0 : store.setValue(name, (prevValue = false) => {
        return getValue2(prevValue, value, defaultChecked);
      });
    }, [store, name, value, defaultChecked]);
    (0, import_react17.useEffect)(() => {
      if (checked === void 0) return;
      store == null ? void 0 : store.setValue(name, (prevValue) => {
        return getValue2(prevValue, value, checked);
      });
    }, [store, name, value, checked]);
    const isChecked = store.useState((state) => state.values[name] === value);
    props = useWrapElement(
      props,
      (element) => (0, import_jsx_runtime10.jsx)(MenuItemCheckedContext2.Provider, { value: !!isChecked, children: element }),
      [isChecked]
    );
    props = __spreadValues({
      role: "menuitemradio"
    }, props);
    props = useRadio(__spreadValues({
      name,
      value,
      checked: isChecked,
      onChange(event) {
        onChangeProp == null ? void 0 : onChangeProp(event);
        if (event.defaultPrevented) return;
        const element = event.currentTarget;
        store == null ? void 0 : store.setValue(name, (prevValue) => {
          return getValue2(prevValue, value, checked != null ? checked : element.checked);
        });
      }
    }, props));
    props = useMenuItem(__spreadValues({ store, hideOnClick }, props));
    return props;
  }
);
var MenuItemRadio = memo2(
  forwardRef2(function MenuItemRadio2(props) {
    const htmlProps = useMenuItemRadio(props);
    return createElement(TagName26, htmlProps);
  })
);

// ../node_modules/@ariakit/react-core/esm/menu/menu-item.js
var import_dist148 = __toESM(require_dist());
var import_dist149 = __toESM(require_dist2());
var import_dist150 = __toESM(require_dist3());

// ../node_modules/@ariakit/react-core/esm/menu/menu-list.js
var import_dist151 = __toESM(require_dist());
var import_dist152 = __toESM(require_dist2());
var import_dist153 = __toESM(require_dist3());

// ../node_modules/@ariakit/react-core/esm/menu/menu-separator.js
var import_dist154 = __toESM(require_dist());
var import_dist155 = __toESM(require_dist2());
var import_dist156 = __toESM(require_dist3());
var TagName27 = "hr";
var useMenuSeparator = createHook(
  function useMenuSeparator2(_a) {
    var _b = _a, { store } = _b, props = __objRest(_b, ["store"]);
    const context = useMenuContext();
    store = store || context;
    props = useCompositeSeparator(__spreadValues({ store }, props));
    return props;
  }
);
var MenuSeparator = forwardRef2(function MenuSeparator2(props) {
  const htmlProps = useMenuSeparator(props);
  return createElement(TagName27, htmlProps);
});

// ../node_modules/@ariakit/react/esm/__chunks/NZJS6FCJ.js
var import_dist157 = __toESM(require_dist(), 1);
var import_dist158 = __toESM(require_dist2(), 1);
var import_dist159 = __toESM(require_dist3(), 1);

export {
  useMenubarContext,
  useHovercardContext,
  useHovercardProviderContext,
  HovercardContextProvider,
  HovercardScopedContextProvider,
  useMenuContext,
  useMenuBarContext,
  createHovercardStore,
  useHovercardStoreProps,
  useHovercardStore,
  useMenuStore,
  useMenubarStore,
  useMenuBarStore,
  MenuList,
  useHovercard,
  Hovercard,
  Menu,
  MenuProvider,
  Menubar,
  MenuBar,
  MenubarProvider,
  MenuBarProvider,
  usePopoverArrow,
  PopoverArrow,
  MenuArrow,
  MenuButtonArrow,
  useHovercardAnchor,
  HovercardAnchor,
  MenuButton,
  DialogDescription,
  PopoverDescription,
  HovercardDescription,
  MenuDescription,
  HovercardDismiss,
  MenuDismiss,
  MenuGroupLabel,
  MenuGroup,
  HovercardHeading,
  MenuHeading,
  MenuItemCheck,
  MenuItem,
  useCheckboxStore,
  useCheckboxContext,
  CheckboxContextProvider,
  useCheckbox,
  Checkbox,
  MenuItemCheckbox,
  useRadioContext,
  useRadioProviderContext,
  RadioContextProvider,
  RadioScopedContextProvider,
  useRadio,
  Radio,
  MenuItemRadio,
  MenuSeparator
};
//# sourceMappingURL=chunk-O7VSBOAK.js.map
