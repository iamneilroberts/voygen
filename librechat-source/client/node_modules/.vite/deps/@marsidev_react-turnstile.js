import __buffer_polyfill from 'vite-plugin-node-polyfills/shims/buffer'
globalThis.Buffer = globalThis.Buffer || __buffer_polyfill
import __global_polyfill from 'vite-plugin-node-polyfills/shims/global'
globalThis.global = globalThis.global || __global_polyfill
import __process_polyfill from 'vite-plugin-node-polyfills/shims/process'
globalThis.process = globalThis.process || __process_polyfill

"use client";
import {
  require_jsx_runtime
} from "./chunk-XB5JEEIH.js";
import {
  require_react
} from "./chunk-FLN3JEFK.js";
import {
  __toESM,
  require_dist,
  require_dist2,
  require_dist3
} from "./chunk-XN4GCD7D.js";

// ../node_modules/@marsidev/react-turnstile/dist/index.js
var import_dist = __toESM(require_dist());
var import_dist2 = __toESM(require_dist2());
var import_dist3 = __toESM(require_dist3());
var import_react = __toESM(require_react());
var import_react2 = __toESM(require_react());
var import_jsx_runtime = __toESM(require_jsx_runtime());
var import_react3 = __toESM(require_react());
var import_jsx_runtime2 = __toESM(require_jsx_runtime());
var se = ({ as: r = "div", ...c }, o) => (0, import_jsx_runtime.jsx)(r, { ...c, ref: o });
var V = (0, import_react2.forwardRef)(se);
var Y = "https://challenges.cloudflare.com/turnstile/v0/api.js";
var w = "cf-turnstile-script";
var A = "cf-turnstile";
var S = "onloadTurnstileCallback";
var D = (r) => !!document.getElementById(r);
var q = ({ render: r = "explicit", onLoadCallbackName: c = S, scriptOptions: { nonce: o = "", defer: e = true, async: p = true, id: x = "", appendTo: C, onError: v, crossOrigin: I = "" } = {} }) => {
  let R = x || w;
  if (D(R)) return;
  let i = document.createElement("script");
  if (i.id = R, i.src = `${Y}?onload=${c}&render=${r}`, document.querySelector(`script[src="${i.src}"]`)) return;
  i.defer = !!e, i.async = !!p, o && (i.nonce = o), I && (i.crossOrigin = I), v && (i.onerror = v, delete window[c]), (C === "body" ? document.body : document.getElementsByTagName("head")[0]).appendChild(i);
};
var l = { normal: { width: 300, height: 65 }, compact: { width: 150, height: 140 }, invisible: { width: 0, height: 0, overflow: "hidden" }, flexible: { minWidth: 300, width: "100%", height: 65 }, interactionOnly: { width: "fit-content", height: "auto", display: "flex" } };
function J(r) {
  if (r !== "invisible" && r !== "interactionOnly") return r;
}
function O(r = w) {
  let [c, o] = (0, import_react3.useState)(false);
  return (0, import_react3.useEffect)(() => {
    let e = () => {
      D(r) && o(true);
    }, p = new MutationObserver(e);
    return p.observe(document, { childList: true, subtree: true }), e(), () => {
      p.disconnect();
    };
  }, [r]), c;
}
var b = "unloaded";
var G;
var fe = new Promise((r, c) => {
  G = { resolve: r, reject: c }, b === "ready" && r(void 0);
});
var me = (r = S) => (b === "unloaded" && (b = "loading", window[r] = () => {
  G.resolve(), b = "ready", delete window[r];
}), fe);
var Te = (0, import_react.forwardRef)((r, c) => {
  let { scriptOptions: o, options: e = {}, siteKey: p, onWidgetLoad: x, onSuccess: C, onExpire: v, onError: I, onBeforeInteractive: R, onAfterInteractive: i, onUnsupported: N, onTimeout: Q, onLoadScript: U, id: Z, style: ee, as: te = "div", injectScript: M = true, ...re } = r, s = e.size, z = (0, import_react.useCallback)(() => typeof s > "u" ? {} : e.execution === "execute" ? l.invisible : e.appearance === "interaction-only" ? l.interactionOnly : l[s], [e.execution, s, e.appearance]), [ne, y] = (0, import_react.useState)(z()), a = (0, import_react.useRef)(null), [f, W] = (0, import_react.useState)(false), t = (0, import_react.useRef)(), h = (0, import_react.useRef)(false), $ = Z || A, P = (o == null ? void 0 : o.id) || w, L = O(P), j = (o == null ? void 0 : o.onLoadCallbackName) || S, oe = e.appearance || "always", g = (0, import_react.useMemo)(() => ({ sitekey: p, action: e.action, cData: e.cData, callback: (n) => {
    h.current = true, C == null ? void 0 : C(n);
  }, "error-callback": I, "expired-callback": v, "before-interactive-callback": R, "after-interactive-callback": i, "unsupported-callback": N, theme: e.theme || "auto", language: e.language || "auto", tabindex: e.tabIndex, "response-field": e.responseField, "response-field-name": e.responseFieldName, size: J(s), retry: e.retry || "auto", "retry-interval": e.retryInterval || 8e3, "refresh-expired": e.refreshExpired || "auto", "refresh-timeout": e.refreshTimeout || "auto", execution: e.execution || "render", appearance: e.appearance || "always", "feedback-enabled": e.feedbackEnabled || true, "timeout-callback": Q }), [e.action, e.appearance, e.cData, e.execution, e.language, e.refreshExpired, e.responseField, e.responseFieldName, e.retry, e.retryInterval, e.tabIndex, e.theme, e.feedbackEnabled, e.refreshTimeout, p, s]), m = (0, import_react.useCallback)(() => typeof window < "u" && !!window.turnstile, []);
  return (0, import_react.useEffect)(function() {
    M && !f && q({ onLoadCallbackName: j, scriptOptions: { ...o, id: P } });
  }, [M, f, o, P]), (0, import_react.useEffect)(function() {
    b !== "ready" && me(j).then(() => W(true)).catch(console.error);
  }, []), (0, import_react.useEffect)(function() {
    if (!a.current || !f) return;
    let u = false;
    return (async () => {
      if (u || !a.current) return;
      let _ = window.turnstile.render(a.current, g);
      t.current = _, t.current && (x == null ? void 0 : x(t.current));
    })(), () => {
      u = true, t.current && (window.turnstile.remove(t.current), h.current = false);
    };
  }, [$, f, g]), (0, import_react.useImperativeHandle)(c, () => {
    let { turnstile: n } = window;
    return { getResponse() {
      if (!(n == null ? void 0 : n.getResponse) || !t.current || !m()) {
        console.warn("Turnstile has not been loaded");
        return;
      }
      return n.getResponse(t.current);
    }, async getResponsePromise(u = 3e4, B = 100) {
      return new Promise((_, k) => {
        let d, H = async () => {
          if (h.current && window.turnstile && t.current) try {
            let T = window.turnstile.getResponse(t.current);
            return d && clearTimeout(d), T ? _(T) : k(new Error("No response received"));
          } catch (T) {
            return d && clearTimeout(d), console.warn("Failed to get response", T), k(new Error("Failed to get response"));
          }
          d || (d = setTimeout(() => {
            d && clearTimeout(d), k(new Error("Timeout"));
          }, u)), await new Promise((T) => setTimeout(T, B)), await H();
        };
        H();
      });
    }, reset() {
      if (!(n == null ? void 0 : n.reset) || !t.current || !m()) {
        console.warn("Turnstile has not been loaded");
        return;
      }
      e.execution === "execute" && y(l.invisible);
      try {
        h.current = false, n.reset(t.current);
      } catch (u) {
        console.warn(`Failed to reset Turnstile widget ${t}`, u);
      }
    }, remove() {
      if (!(n == null ? void 0 : n.remove) || !t.current || !m()) {
        console.warn("Turnstile has not been loaded");
        return;
      }
      y(l.invisible), h.current = false, n.remove(t.current), t.current = null;
    }, render() {
      if (!(n == null ? void 0 : n.render) || !a.current || !m() || t.current) {
        console.warn("Turnstile has not been loaded or container not found");
        return;
      }
      let u = n.render(a.current, g);
      return t.current = u, t.current && (x == null ? void 0 : x(t.current)), e.execution !== "execute" && y(s ? l[s] : {}), u;
    }, execute() {
      if (e.execution !== "execute") {
        console.warn('Execution mode is not set to "execute"');
        return;
      }
      if (!(n == null ? void 0 : n.execute) || !a.current || !t.current || !m()) {
        console.warn("Turnstile has not been loaded or container not found");
        return;
      }
      n.execute(a.current, g), y(s ? l[s] : {});
    }, isExpired() {
      return !(n == null ? void 0 : n.isExpired) || !t.current || !m() ? (console.warn("Turnstile has not been loaded"), false) : n.isExpired(t.current);
    } };
  }, [t, e.execution, s, g, a, m, f, x]), (0, import_react.useEffect)(() => {
    L && !f && window.turnstile && W(true);
  }, [f, L]), (0, import_react.useEffect)(() => {
    y(z());
  }, [e.execution, s, oe]), (0, import_react.useEffect)(() => {
    !L || typeof U != "function" || U();
  }, [L]), (0, import_jsx_runtime2.jsx)(V, { ref: a, as: te, id: $, style: { ...ne, ...ee }, ...re });
});
Te.displayName = "Turnstile";
export {
  A as DEFAULT_CONTAINER_ID,
  S as DEFAULT_ONLOAD_NAME,
  w as DEFAULT_SCRIPT_ID,
  Y as SCRIPT_URL,
  Te as Turnstile
};
//# sourceMappingURL=@marsidev_react-turnstile.js.map
