import __buffer_polyfill from 'vite-plugin-node-polyfills/shims/buffer'
globalThis.Buffer = globalThis.Buffer || __buffer_polyfill
import __global_polyfill from 'vite-plugin-node-polyfills/shims/global'
globalThis.global = globalThis.global || __global_polyfill
import __process_polyfill from 'vite-plugin-node-polyfills/shims/process'
globalThis.process = globalThis.process || __process_polyfill

import {
  decodeNamedCharacterReference,
  factoryWhitespace
} from "./chunk-Y2YF3YR5.js";
import {
  asciiAlpha,
  asciiAlphanumeric,
  codes,
  constants,
  factorySpace,
  markdownLineEnding,
  markdownLineEndingOrSpace,
  markdownSpace,
  ok,
  types
} from "./chunk-E5RWLMUQ.js";
import "./chunk-TH2XZ6BX.js";
import {
  __toESM,
  require_dist,
  require_dist2,
  require_dist3
} from "./chunk-XN4GCD7D.js";

// ../node_modules/remark-directive/index.js
var import_dist106 = __toESM(require_dist());
var import_dist107 = __toESM(require_dist2());
var import_dist108 = __toESM(require_dist3());

// ../node_modules/remark-directive/lib/index.js
var import_dist103 = __toESM(require_dist(), 1);
var import_dist104 = __toESM(require_dist2(), 1);
var import_dist105 = __toESM(require_dist3(), 1);

// ../node_modules/mdast-util-directive/index.js
var import_dist73 = __toESM(require_dist());
var import_dist74 = __toESM(require_dist2());
var import_dist75 = __toESM(require_dist3());

// ../node_modules/mdast-util-directive/lib/index.js
var import_dist70 = __toESM(require_dist(), 1);
var import_dist71 = __toESM(require_dist2(), 1);
var import_dist72 = __toESM(require_dist3(), 1);

// ../node_modules/parse-entities/index.js
var import_dist22 = __toESM(require_dist());
var import_dist23 = __toESM(require_dist2());
var import_dist24 = __toESM(require_dist3());

// ../node_modules/parse-entities/lib/index.js
var import_dist19 = __toESM(require_dist(), 1);
var import_dist20 = __toESM(require_dist2(), 1);
var import_dist21 = __toESM(require_dist3(), 1);

// ../node_modules/character-entities-legacy/index.js
var import_dist = __toESM(require_dist());
var import_dist2 = __toESM(require_dist2());
var import_dist3 = __toESM(require_dist3());
var characterEntitiesLegacy = [
  "AElig",
  "AMP",
  "Aacute",
  "Acirc",
  "Agrave",
  "Aring",
  "Atilde",
  "Auml",
  "COPY",
  "Ccedil",
  "ETH",
  "Eacute",
  "Ecirc",
  "Egrave",
  "Euml",
  "GT",
  "Iacute",
  "Icirc",
  "Igrave",
  "Iuml",
  "LT",
  "Ntilde",
  "Oacute",
  "Ocirc",
  "Ograve",
  "Oslash",
  "Otilde",
  "Ouml",
  "QUOT",
  "REG",
  "THORN",
  "Uacute",
  "Ucirc",
  "Ugrave",
  "Uuml",
  "Yacute",
  "aacute",
  "acirc",
  "acute",
  "aelig",
  "agrave",
  "amp",
  "aring",
  "atilde",
  "auml",
  "brvbar",
  "ccedil",
  "cedil",
  "cent",
  "copy",
  "curren",
  "deg",
  "divide",
  "eacute",
  "ecirc",
  "egrave",
  "eth",
  "euml",
  "frac12",
  "frac14",
  "frac34",
  "gt",
  "iacute",
  "icirc",
  "iexcl",
  "igrave",
  "iquest",
  "iuml",
  "laquo",
  "lt",
  "macr",
  "micro",
  "middot",
  "nbsp",
  "not",
  "ntilde",
  "oacute",
  "ocirc",
  "ograve",
  "ordf",
  "ordm",
  "oslash",
  "otilde",
  "ouml",
  "para",
  "plusmn",
  "pound",
  "quot",
  "raquo",
  "reg",
  "sect",
  "shy",
  "sup1",
  "sup2",
  "sup3",
  "szlig",
  "thorn",
  "times",
  "uacute",
  "ucirc",
  "ugrave",
  "uml",
  "uuml",
  "yacute",
  "yen",
  "yuml"
];

// ../node_modules/character-reference-invalid/index.js
var import_dist4 = __toESM(require_dist());
var import_dist5 = __toESM(require_dist2());
var import_dist6 = __toESM(require_dist3());
var characterReferenceInvalid = {
  0: "�",
  128: "€",
  130: "‚",
  131: "ƒ",
  132: "„",
  133: "…",
  134: "†",
  135: "‡",
  136: "ˆ",
  137: "‰",
  138: "Š",
  139: "‹",
  140: "Œ",
  142: "Ž",
  145: "‘",
  146: "’",
  147: "“",
  148: "”",
  149: "•",
  150: "–",
  151: "—",
  152: "˜",
  153: "™",
  154: "š",
  155: "›",
  156: "œ",
  158: "ž",
  159: "Ÿ"
};

// ../node_modules/is-decimal/index.js
var import_dist7 = __toESM(require_dist());
var import_dist8 = __toESM(require_dist2());
var import_dist9 = __toESM(require_dist3());
function isDecimal(character) {
  const code = typeof character === "string" ? character.charCodeAt(0) : character;
  return code >= 48 && code <= 57;
}

// ../node_modules/is-hexadecimal/index.js
var import_dist10 = __toESM(require_dist());
var import_dist11 = __toESM(require_dist2());
var import_dist12 = __toESM(require_dist3());
function isHexadecimal(character) {
  const code = typeof character === "string" ? character.charCodeAt(0) : character;
  return code >= 97 && code <= 102 || code >= 65 && code <= 70 || code >= 48 && code <= 57;
}

// ../node_modules/is-alphanumerical/index.js
var import_dist16 = __toESM(require_dist());
var import_dist17 = __toESM(require_dist2());
var import_dist18 = __toESM(require_dist3());

// ../node_modules/is-alphabetical/index.js
var import_dist13 = __toESM(require_dist());
var import_dist14 = __toESM(require_dist2());
var import_dist15 = __toESM(require_dist3());
function isAlphabetical(character) {
  const code = typeof character === "string" ? character.charCodeAt(0) : character;
  return code >= 97 && code <= 122 || code >= 65 && code <= 90;
}

// ../node_modules/is-alphanumerical/index.js
function isAlphanumerical(character) {
  return isAlphabetical(character) || isDecimal(character);
}

// ../node_modules/parse-entities/lib/index.js
var fromCharCode = String.fromCharCode;
var messages = [
  "",
  /* 1: Non terminated (named) */
  "Named character references must be terminated by a semicolon",
  /* 2: Non terminated (numeric) */
  "Numeric character references must be terminated by a semicolon",
  /* 3: Empty (named) */
  "Named character references cannot be empty",
  /* 4: Empty (numeric) */
  "Numeric character references cannot be empty",
  /* 5: Unknown (named) */
  "Named character references must be known",
  /* 6: Disallowed (numeric) */
  "Numeric character references cannot be disallowed",
  /* 7: Prohibited (numeric) */
  "Numeric character references cannot be outside the permissible Unicode range"
];
function parseEntities(value, options = {}) {
  const additional = typeof options.additional === "string" ? options.additional.charCodeAt(0) : options.additional;
  const result = [];
  let index = 0;
  let lines = -1;
  let queue = "";
  let point;
  let indent;
  if (options.position) {
    if ("start" in options.position || "indent" in options.position) {
      indent = options.position.indent;
      point = options.position.start;
    } else {
      point = options.position;
    }
  }
  let line = (point ? point.line : 0) || 1;
  let column = (point ? point.column : 0) || 1;
  let previous2 = now();
  let character;
  index--;
  while (++index <= value.length) {
    if (character === 10) {
      column = (indent ? indent[lines] : 0) || 1;
    }
    character = value.charCodeAt(index);
    if (character === 38) {
      const following = value.charCodeAt(index + 1);
      if (following === 9 || following === 10 || following === 12 || following === 32 || following === 38 || following === 60 || Number.isNaN(following) || additional && following === additional) {
        queue += fromCharCode(character);
        column++;
        continue;
      }
      const start = index + 1;
      let begin = start;
      let end = start;
      let type;
      if (following === 35) {
        end = ++begin;
        const following2 = value.charCodeAt(end);
        if (following2 === 88 || following2 === 120) {
          type = "hexadecimal";
          end = ++begin;
        } else {
          type = "decimal";
        }
      } else {
        type = "named";
      }
      let characterReferenceCharacters = "";
      let characterReference = "";
      let characters2 = "";
      const test = type === "named" ? isAlphanumerical : type === "decimal" ? isDecimal : isHexadecimal;
      end--;
      while (++end <= value.length) {
        const following2 = value.charCodeAt(end);
        if (!test(following2)) {
          break;
        }
        characters2 += fromCharCode(following2);
        if (type === "named" && characterEntitiesLegacy.includes(characters2)) {
          characterReferenceCharacters = characters2;
          characterReference = decodeNamedCharacterReference(characters2);
        }
      }
      let terminated = value.charCodeAt(end) === 59;
      if (terminated) {
        end++;
        const namedReference = type === "named" ? decodeNamedCharacterReference(characters2) : false;
        if (namedReference) {
          characterReferenceCharacters = characters2;
          characterReference = namedReference;
        }
      }
      let diff = 1 + end - start;
      let reference = "";
      if (!terminated && options.nonTerminated === false) {
      } else if (!characters2) {
        if (type !== "named") {
          warning(4, diff);
        }
      } else if (type === "named") {
        if (terminated && !characterReference) {
          warning(5, 1);
        } else {
          if (characterReferenceCharacters !== characters2) {
            end = begin + characterReferenceCharacters.length;
            diff = 1 + end - begin;
            terminated = false;
          }
          if (!terminated) {
            const reason = characterReferenceCharacters ? 1 : 3;
            if (options.attribute) {
              const following2 = value.charCodeAt(end);
              if (following2 === 61) {
                warning(reason, diff);
                characterReference = "";
              } else if (isAlphanumerical(following2)) {
                characterReference = "";
              } else {
                warning(reason, diff);
              }
            } else {
              warning(reason, diff);
            }
          }
        }
        reference = characterReference;
      } else {
        if (!terminated) {
          warning(2, diff);
        }
        let referenceCode = Number.parseInt(
          characters2,
          type === "hexadecimal" ? 16 : 10
        );
        if (prohibited(referenceCode)) {
          warning(7, diff);
          reference = fromCharCode(
            65533
            /* `�` */
          );
        } else if (referenceCode in characterReferenceInvalid) {
          warning(6, diff);
          reference = characterReferenceInvalid[referenceCode];
        } else {
          let output = "";
          if (disallowed(referenceCode)) {
            warning(6, diff);
          }
          if (referenceCode > 65535) {
            referenceCode -= 65536;
            output += fromCharCode(referenceCode >>> (10 & 1023) | 55296);
            referenceCode = 56320 | referenceCode & 1023;
          }
          reference = output + fromCharCode(referenceCode);
        }
      }
      if (reference) {
        flush();
        previous2 = now();
        index = end - 1;
        column += end - start + 1;
        result.push(reference);
        const next = now();
        next.offset++;
        if (options.reference) {
          options.reference.call(
            options.referenceContext,
            reference,
            { start: previous2, end: next },
            value.slice(start - 1, end)
          );
        }
        previous2 = next;
      } else {
        characters2 = value.slice(start - 1, end);
        queue += characters2;
        column += characters2.length;
        index = end - 1;
      }
    } else {
      if (character === 10) {
        line++;
        lines++;
        column = 0;
      }
      if (Number.isNaN(character)) {
        flush();
      } else {
        queue += fromCharCode(character);
        column++;
      }
    }
  }
  return result.join("");
  function now() {
    return {
      line,
      column,
      offset: index + ((point ? point.offset : 0) || 0)
    };
  }
  function warning(code, offset) {
    let position;
    if (options.warning) {
      position = now();
      position.column += offset;
      position.offset += offset;
      options.warning.call(
        options.warningContext,
        messages[code],
        position,
        code
      );
    }
  }
  function flush() {
    if (queue) {
      result.push(queue);
      if (options.text) {
        options.text.call(options.textContext, queue, {
          start: previous2,
          end: now()
        });
      }
      queue = "";
    }
  }
}
function prohibited(code) {
  return code >= 55296 && code <= 57343 || code > 1114111;
}
function disallowed(code) {
  return code >= 1 && code <= 8 || code === 11 || code >= 13 && code <= 31 || code >= 127 && code <= 159 || code >= 64976 && code <= 65007 || (code & 65535) === 65535 || (code & 65535) === 65534;
}

// ../node_modules/stringify-entities/index.js
var import_dist52 = __toESM(require_dist());
var import_dist53 = __toESM(require_dist2());
var import_dist54 = __toESM(require_dist3());

// ../node_modules/stringify-entities/lib/index.js
var import_dist49 = __toESM(require_dist(), 1);
var import_dist50 = __toESM(require_dist2(), 1);
var import_dist51 = __toESM(require_dist3(), 1);

// ../node_modules/stringify-entities/lib/core.js
var import_dist25 = __toESM(require_dist(), 1);
var import_dist26 = __toESM(require_dist2(), 1);
var import_dist27 = __toESM(require_dist3(), 1);
var defaultSubsetRegex = /["&'<>`]/g;
var surrogatePairsRegex = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
var controlCharactersRegex = (
  // eslint-disable-next-line no-control-regex, unicorn/no-hex-escape
  /[\x01-\t\v\f\x0E-\x1F\x7F\x81\x8D\x8F\x90\x9D\xA0-\uFFFF]/g
);
var regexEscapeRegex = /[|\\{}()[\]^$+*?.]/g;
var subsetToRegexCache = /* @__PURE__ */ new WeakMap();
function core(value, options) {
  value = value.replace(
    options.subset ? charactersToExpressionCached(options.subset) : defaultSubsetRegex,
    basic
  );
  if (options.subset || options.escapeOnly) {
    return value;
  }
  return value.replace(surrogatePairsRegex, surrogate).replace(controlCharactersRegex, basic);
  function surrogate(pair, index, all) {
    return options.format(
      (pair.charCodeAt(0) - 55296) * 1024 + pair.charCodeAt(1) - 56320 + 65536,
      all.charCodeAt(index + 2),
      options
    );
  }
  function basic(character, index, all) {
    return options.format(
      character.charCodeAt(0),
      all.charCodeAt(index + 1),
      options
    );
  }
}
function charactersToExpressionCached(subset) {
  let cached = subsetToRegexCache.get(subset);
  if (!cached) {
    cached = charactersToExpression(subset);
    subsetToRegexCache.set(subset, cached);
  }
  return cached;
}
function charactersToExpression(subset) {
  const groups = [];
  let index = -1;
  while (++index < subset.length) {
    groups.push(subset[index].replace(regexEscapeRegex, "\\$&"));
  }
  return new RegExp("(?:" + groups.join("|") + ")", "g");
}

// ../node_modules/stringify-entities/lib/util/format-smart.js
var import_dist43 = __toESM(require_dist(), 1);
var import_dist44 = __toESM(require_dist2(), 1);
var import_dist45 = __toESM(require_dist3(), 1);

// ../node_modules/stringify-entities/lib/util/to-hexadecimal.js
var import_dist28 = __toESM(require_dist(), 1);
var import_dist29 = __toESM(require_dist2(), 1);
var import_dist30 = __toESM(require_dist3(), 1);

// ../node_modules/stringify-entities/lib/util/to-decimal.js
var import_dist31 = __toESM(require_dist(), 1);
var import_dist32 = __toESM(require_dist2(), 1);
var import_dist33 = __toESM(require_dist3(), 1);

// ../node_modules/stringify-entities/lib/util/to-named.js
var import_dist40 = __toESM(require_dist(), 1);
var import_dist41 = __toESM(require_dist2(), 1);
var import_dist42 = __toESM(require_dist3(), 1);

// ../node_modules/character-entities-html4/index.js
var import_dist34 = __toESM(require_dist());
var import_dist35 = __toESM(require_dist2());
var import_dist36 = __toESM(require_dist3());
var characterEntitiesHtml4 = {
  nbsp: " ",
  iexcl: "¡",
  cent: "¢",
  pound: "£",
  curren: "¤",
  yen: "¥",
  brvbar: "¦",
  sect: "§",
  uml: "¨",
  copy: "©",
  ordf: "ª",
  laquo: "«",
  not: "¬",
  shy: "­",
  reg: "®",
  macr: "¯",
  deg: "°",
  plusmn: "±",
  sup2: "²",
  sup3: "³",
  acute: "´",
  micro: "µ",
  para: "¶",
  middot: "·",
  cedil: "¸",
  sup1: "¹",
  ordm: "º",
  raquo: "»",
  frac14: "¼",
  frac12: "½",
  frac34: "¾",
  iquest: "¿",
  Agrave: "À",
  Aacute: "Á",
  Acirc: "Â",
  Atilde: "Ã",
  Auml: "Ä",
  Aring: "Å",
  AElig: "Æ",
  Ccedil: "Ç",
  Egrave: "È",
  Eacute: "É",
  Ecirc: "Ê",
  Euml: "Ë",
  Igrave: "Ì",
  Iacute: "Í",
  Icirc: "Î",
  Iuml: "Ï",
  ETH: "Ð",
  Ntilde: "Ñ",
  Ograve: "Ò",
  Oacute: "Ó",
  Ocirc: "Ô",
  Otilde: "Õ",
  Ouml: "Ö",
  times: "×",
  Oslash: "Ø",
  Ugrave: "Ù",
  Uacute: "Ú",
  Ucirc: "Û",
  Uuml: "Ü",
  Yacute: "Ý",
  THORN: "Þ",
  szlig: "ß",
  agrave: "à",
  aacute: "á",
  acirc: "â",
  atilde: "ã",
  auml: "ä",
  aring: "å",
  aelig: "æ",
  ccedil: "ç",
  egrave: "è",
  eacute: "é",
  ecirc: "ê",
  euml: "ë",
  igrave: "ì",
  iacute: "í",
  icirc: "î",
  iuml: "ï",
  eth: "ð",
  ntilde: "ñ",
  ograve: "ò",
  oacute: "ó",
  ocirc: "ô",
  otilde: "õ",
  ouml: "ö",
  divide: "÷",
  oslash: "ø",
  ugrave: "ù",
  uacute: "ú",
  ucirc: "û",
  uuml: "ü",
  yacute: "ý",
  thorn: "þ",
  yuml: "ÿ",
  fnof: "ƒ",
  Alpha: "Α",
  Beta: "Β",
  Gamma: "Γ",
  Delta: "Δ",
  Epsilon: "Ε",
  Zeta: "Ζ",
  Eta: "Η",
  Theta: "Θ",
  Iota: "Ι",
  Kappa: "Κ",
  Lambda: "Λ",
  Mu: "Μ",
  Nu: "Ν",
  Xi: "Ξ",
  Omicron: "Ο",
  Pi: "Π",
  Rho: "Ρ",
  Sigma: "Σ",
  Tau: "Τ",
  Upsilon: "Υ",
  Phi: "Φ",
  Chi: "Χ",
  Psi: "Ψ",
  Omega: "Ω",
  alpha: "α",
  beta: "β",
  gamma: "γ",
  delta: "δ",
  epsilon: "ε",
  zeta: "ζ",
  eta: "η",
  theta: "θ",
  iota: "ι",
  kappa: "κ",
  lambda: "λ",
  mu: "μ",
  nu: "ν",
  xi: "ξ",
  omicron: "ο",
  pi: "π",
  rho: "ρ",
  sigmaf: "ς",
  sigma: "σ",
  tau: "τ",
  upsilon: "υ",
  phi: "φ",
  chi: "χ",
  psi: "ψ",
  omega: "ω",
  thetasym: "ϑ",
  upsih: "ϒ",
  piv: "ϖ",
  bull: "•",
  hellip: "…",
  prime: "′",
  Prime: "″",
  oline: "‾",
  frasl: "⁄",
  weierp: "℘",
  image: "ℑ",
  real: "ℜ",
  trade: "™",
  alefsym: "ℵ",
  larr: "←",
  uarr: "↑",
  rarr: "→",
  darr: "↓",
  harr: "↔",
  crarr: "↵",
  lArr: "⇐",
  uArr: "⇑",
  rArr: "⇒",
  dArr: "⇓",
  hArr: "⇔",
  forall: "∀",
  part: "∂",
  exist: "∃",
  empty: "∅",
  nabla: "∇",
  isin: "∈",
  notin: "∉",
  ni: "∋",
  prod: "∏",
  sum: "∑",
  minus: "−",
  lowast: "∗",
  radic: "√",
  prop: "∝",
  infin: "∞",
  ang: "∠",
  and: "∧",
  or: "∨",
  cap: "∩",
  cup: "∪",
  int: "∫",
  there4: "∴",
  sim: "∼",
  cong: "≅",
  asymp: "≈",
  ne: "≠",
  equiv: "≡",
  le: "≤",
  ge: "≥",
  sub: "⊂",
  sup: "⊃",
  nsub: "⊄",
  sube: "⊆",
  supe: "⊇",
  oplus: "⊕",
  otimes: "⊗",
  perp: "⊥",
  sdot: "⋅",
  lceil: "⌈",
  rceil: "⌉",
  lfloor: "⌊",
  rfloor: "⌋",
  lang: "〈",
  rang: "〉",
  loz: "◊",
  spades: "♠",
  clubs: "♣",
  hearts: "♥",
  diams: "♦",
  quot: '"',
  amp: "&",
  lt: "<",
  gt: ">",
  OElig: "Œ",
  oelig: "œ",
  Scaron: "Š",
  scaron: "š",
  Yuml: "Ÿ",
  circ: "ˆ",
  tilde: "˜",
  ensp: " ",
  emsp: " ",
  thinsp: " ",
  zwnj: "‌",
  zwj: "‍",
  lrm: "‎",
  rlm: "‏",
  ndash: "–",
  mdash: "—",
  lsquo: "‘",
  rsquo: "’",
  sbquo: "‚",
  ldquo: "“",
  rdquo: "”",
  bdquo: "„",
  dagger: "†",
  Dagger: "‡",
  permil: "‰",
  lsaquo: "‹",
  rsaquo: "›",
  euro: "€"
};

// ../node_modules/stringify-entities/lib/constant/dangerous.js
var import_dist37 = __toESM(require_dist(), 1);
var import_dist38 = __toESM(require_dist2(), 1);
var import_dist39 = __toESM(require_dist3(), 1);

// ../node_modules/stringify-entities/lib/util/to-named.js
var own = {}.hasOwnProperty;
var characters = {};
var key;
for (key in characterEntitiesHtml4) {
  if (own.call(characterEntitiesHtml4, key)) {
    characters[characterEntitiesHtml4[key]] = key;
  }
}

// ../node_modules/stringify-entities/lib/util/format-basic.js
var import_dist46 = __toESM(require_dist(), 1);
var import_dist47 = __toESM(require_dist2(), 1);
var import_dist48 = __toESM(require_dist3(), 1);
function formatBasic(code) {
  return "&#x" + code.toString(16).toUpperCase() + ";";
}

// ../node_modules/stringify-entities/lib/index.js
function stringifyEntitiesLight(value, options) {
  return core(value, Object.assign({ format: formatBasic }, options));
}

// ../node_modules/mdast-util-directive/node_modules/unist-util-visit-parents/index.js
var import_dist67 = __toESM(require_dist());
var import_dist68 = __toESM(require_dist2());
var import_dist69 = __toESM(require_dist3());

// ../node_modules/mdast-util-directive/node_modules/unist-util-visit-parents/lib/index.js
var import_dist64 = __toESM(require_dist(), 1);
var import_dist65 = __toESM(require_dist2(), 1);
var import_dist66 = __toESM(require_dist3(), 1);

// ../node_modules/mdast-util-directive/node_modules/unist-util-is/index.js
var import_dist58 = __toESM(require_dist());
var import_dist59 = __toESM(require_dist2());
var import_dist60 = __toESM(require_dist3());

// ../node_modules/mdast-util-directive/node_modules/unist-util-is/lib/index.js
var import_dist55 = __toESM(require_dist(), 1);
var import_dist56 = __toESM(require_dist2(), 1);
var import_dist57 = __toESM(require_dist3(), 1);
var convert = (
  // Note: overloads in JSDoc can’t yet use different `@template`s.
  /**
   * @type {(
   *   (<Condition extends string>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & {type: Condition}) &
   *   (<Condition extends Props>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Condition) &
   *   (<Condition extends TestFunction>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Predicate<Condition, Node>) &
   *   ((test?: null | undefined) => (node?: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node) &
   *   ((test?: Test) => Check)
   * )}
   */
  /**
   * @param {Test} [test]
   * @returns {Check}
   */
  function(test) {
    if (test === null || test === void 0) {
      return ok2;
    }
    if (typeof test === "function") {
      return castFactory(test);
    }
    if (typeof test === "object") {
      return Array.isArray(test) ? anyFactory(test) : propsFactory(test);
    }
    if (typeof test === "string") {
      return typeFactory(test);
    }
    throw new Error("Expected function, string, or object as test");
  }
);
function anyFactory(tests) {
  const checks = [];
  let index = -1;
  while (++index < tests.length) {
    checks[index] = convert(tests[index]);
  }
  return castFactory(any);
  function any(...parameters) {
    let index2 = -1;
    while (++index2 < checks.length) {
      if (checks[index2].apply(this, parameters)) return true;
    }
    return false;
  }
}
function propsFactory(check) {
  const checkAsRecord = (
    /** @type {Record<string, unknown>} */
    check
  );
  return castFactory(all);
  function all(node) {
    const nodeAsRecord = (
      /** @type {Record<string, unknown>} */
      /** @type {unknown} */
      node
    );
    let key2;
    for (key2 in check) {
      if (nodeAsRecord[key2] !== checkAsRecord[key2]) return false;
    }
    return true;
  }
}
function typeFactory(check) {
  return castFactory(type);
  function type(node) {
    return node && node.type === check;
  }
}
function castFactory(testFunction) {
  return check;
  function check(value, index, parent) {
    return Boolean(
      looksLikeANode(value) && testFunction.call(
        this,
        value,
        typeof index === "number" ? index : void 0,
        parent || void 0
      )
    );
  }
}
function ok2() {
  return true;
}
function looksLikeANode(value) {
  return value !== null && typeof value === "object" && "type" in value;
}

// ../node_modules/mdast-util-directive/node_modules/unist-util-visit-parents/lib/color.js
var import_dist61 = __toESM(require_dist());
var import_dist62 = __toESM(require_dist2());
var import_dist63 = __toESM(require_dist3());
function color(d) {
  return d;
}

// ../node_modules/mdast-util-directive/node_modules/unist-util-visit-parents/lib/index.js
var empty = [];
var CONTINUE = true;
var EXIT = false;
var SKIP = "skip";
function visitParents(tree, test, visitor, reverse) {
  let check;
  if (typeof test === "function" && typeof visitor !== "function") {
    reverse = visitor;
    visitor = test;
  } else {
    check = test;
  }
  const is2 = convert(check);
  const step = reverse ? -1 : 1;
  factory(tree, void 0, [])();
  function factory(node, index, parents) {
    const value = (
      /** @type {Record<string, unknown>} */
      node && typeof node === "object" ? node : {}
    );
    if (typeof value.type === "string") {
      const name = (
        // `hast`
        typeof value.tagName === "string" ? value.tagName : (
          // `xast`
          typeof value.name === "string" ? value.name : void 0
        )
      );
      Object.defineProperty(visit, "name", {
        value: "node (" + color(node.type + (name ? "<" + name + ">" : "")) + ")"
      });
    }
    return visit;
    function visit() {
      let result = empty;
      let subresult;
      let offset;
      let grandparents;
      if (!test || is2(node, index, parents[parents.length - 1] || void 0)) {
        result = toResult(visitor(node, parents));
        if (result[0] === EXIT) {
          return result;
        }
      }
      if ("children" in node && node.children) {
        const nodeAsParent = (
          /** @type {UnistParent} */
          node
        );
        if (nodeAsParent.children && result[0] !== SKIP) {
          offset = (reverse ? nodeAsParent.children.length : -1) + step;
          grandparents = parents.concat(nodeAsParent);
          while (offset > -1 && offset < nodeAsParent.children.length) {
            const child = nodeAsParent.children[offset];
            subresult = factory(child, offset, grandparents)();
            if (subresult[0] === EXIT) {
              return subresult;
            }
            offset = typeof subresult[1] === "number" ? subresult[1] : offset + step;
          }
        }
      }
      return result;
    }
  }
}
function toResult(value) {
  if (Array.isArray(value)) {
    return value;
  }
  if (typeof value === "number") {
    return [CONTINUE, value];
  }
  return value === null || value === void 0 ? empty : [value];
}

// ../node_modules/mdast-util-directive/lib/index.js
var own2 = {}.hasOwnProperty;
var shortcut = /^[^\t\n\r "#'.<=>`}]+$/;
handleDirective.peek = peekDirective;
function directiveFromMarkdown() {
  return {
    canContainEols: ["textDirective"],
    enter: {
      directiveContainer: enterContainer,
      directiveContainerAttributes: enterAttributes,
      directiveContainerLabel: enterContainerLabel,
      directiveLeaf: enterLeaf,
      directiveLeafAttributes: enterAttributes,
      directiveText: enterText,
      directiveTextAttributes: enterAttributes
    },
    exit: {
      directiveContainer: exit,
      directiveContainerAttributeClassValue: exitAttributeClassValue,
      directiveContainerAttributeIdValue: exitAttributeIdValue,
      directiveContainerAttributeName: exitAttributeName,
      directiveContainerAttributeValue: exitAttributeValue,
      directiveContainerAttributes: exitAttributes,
      directiveContainerLabel: exitContainerLabel,
      directiveContainerName: exitName,
      directiveLeaf: exit,
      directiveLeafAttributeClassValue: exitAttributeClassValue,
      directiveLeafAttributeIdValue: exitAttributeIdValue,
      directiveLeafAttributeName: exitAttributeName,
      directiveLeafAttributeValue: exitAttributeValue,
      directiveLeafAttributes: exitAttributes,
      directiveLeafName: exitName,
      directiveText: exit,
      directiveTextAttributeClassValue: exitAttributeClassValue,
      directiveTextAttributeIdValue: exitAttributeIdValue,
      directiveTextAttributeName: exitAttributeName,
      directiveTextAttributeValue: exitAttributeValue,
      directiveTextAttributes: exitAttributes,
      directiveTextName: exitName
    }
  };
}
function directiveToMarkdown() {
  return {
    unsafe: [
      {
        character: "\r",
        inConstruct: ["leafDirectiveLabel", "containerDirectiveLabel"]
      },
      {
        character: "\n",
        inConstruct: ["leafDirectiveLabel", "containerDirectiveLabel"]
      },
      {
        before: "[^:]",
        character: ":",
        after: "[A-Za-z]",
        inConstruct: ["phrasing"]
      },
      { atBreak: true, character: ":", after: ":" }
    ],
    handlers: {
      containerDirective: handleDirective,
      leafDirective: handleDirective,
      textDirective: handleDirective
    }
  };
}
function enterContainer(token) {
  enter.call(this, "containerDirective", token);
}
function enterLeaf(token) {
  enter.call(this, "leafDirective", token);
}
function enterText(token) {
  enter.call(this, "textDirective", token);
}
function enter(type, token) {
  this.enter({ type, name: "", attributes: {}, children: [] }, token);
}
function exitName(token) {
  const node = this.stack[this.stack.length - 1];
  ok(
    node.type === "containerDirective" || node.type === "leafDirective" || node.type === "textDirective"
  );
  node.name = this.sliceSerialize(token);
}
function enterContainerLabel(token) {
  this.enter(
    { type: "paragraph", data: { directiveLabel: true }, children: [] },
    token
  );
}
function exitContainerLabel(token) {
  this.exit(token);
}
function enterAttributes() {
  this.data.directiveAttributes = [];
  this.buffer();
}
function exitAttributeIdValue(token) {
  const list = this.data.directiveAttributes;
  ok(list, "expected `directiveAttributes`");
  list.push([
    "id",
    parseEntities(this.sliceSerialize(token), {
      attribute: true
    })
  ]);
}
function exitAttributeClassValue(token) {
  const list = this.data.directiveAttributes;
  ok(list, "expected `directiveAttributes`");
  list.push([
    "class",
    parseEntities(this.sliceSerialize(token), {
      attribute: true
    })
  ]);
}
function exitAttributeValue(token) {
  const list = this.data.directiveAttributes;
  ok(list, "expected `directiveAttributes`");
  list[list.length - 1][1] = parseEntities(this.sliceSerialize(token), {
    attribute: true
  });
}
function exitAttributeName(token) {
  const list = this.data.directiveAttributes;
  ok(list, "expected `directiveAttributes`");
  list.push([this.sliceSerialize(token), ""]);
}
function exitAttributes() {
  const list = this.data.directiveAttributes;
  ok(list, "expected `directiveAttributes`");
  const cleaned = {};
  let index = -1;
  while (++index < list.length) {
    const attribute = list[index];
    if (attribute[0] === "class" && cleaned.class) {
      cleaned.class += " " + attribute[1];
    } else {
      cleaned[attribute[0]] = attribute[1];
    }
  }
  this.data.directiveAttributes = void 0;
  this.resume();
  const node = this.stack[this.stack.length - 1];
  ok(
    node.type === "containerDirective" || node.type === "leafDirective" || node.type === "textDirective"
  );
  node.attributes = cleaned;
}
function exit(token) {
  this.exit(token);
}
function handleDirective(node, _, state, info) {
  const tracker = state.createTracker(info);
  const sequence = fence(node);
  const exit2 = state.enter(node.type);
  let value = tracker.move(sequence + (node.name || ""));
  let label4;
  if (node.type === "containerDirective") {
    const head = (node.children || [])[0];
    label4 = inlineDirectiveLabel(head) ? head : void 0;
  } else {
    label4 = node;
  }
  if (label4 && label4.children && label4.children.length > 0) {
    const exit3 = state.enter("label");
    const labelType = `${node.type}Label`;
    const subexit = state.enter(labelType);
    value += tracker.move("[");
    value += tracker.move(
      // @ts-expect-error: `containerPhrasing` is typed correctly, but TS
      // generates *hardcoded* types, which means that our dynamically added
      // directives are not present.
      // At some point, TS should fix that, and `from-markdown` should be fine.
      state.containerPhrasing(label4, {
        ...tracker.current(),
        before: value,
        after: "]"
      })
    );
    value += tracker.move("]");
    subexit();
    exit3();
  }
  value += tracker.move(attributes(node, state));
  if (node.type === "containerDirective") {
    const head = (node.children || [])[0];
    let shallow = node;
    if (inlineDirectiveLabel(head)) {
      shallow = Object.assign({}, node, { children: node.children.slice(1) });
    }
    if (shallow && shallow.children && shallow.children.length > 0) {
      value += tracker.move("\n");
      value += tracker.move(state.containerFlow(shallow, tracker.current()));
    }
    value += tracker.move("\n" + sequence);
  }
  exit2();
  return value;
}
function peekDirective() {
  return ":";
}
function attributes(node, state) {
  const quote = state.options.quote || '"';
  const subset = node.type === "textDirective" ? [quote] : [quote, "\n", "\r"];
  const attrs = node.attributes || {};
  const values = [];
  let classesFull;
  let classes;
  let id;
  let key2;
  for (key2 in attrs) {
    if (own2.call(attrs, key2) && attrs[key2] !== void 0 && attrs[key2] !== null) {
      const value = String(attrs[key2]);
      if (key2 === "id") {
        id = shortcut.test(value) ? "#" + value : quoted("id", value);
      } else if (key2 === "class") {
        const list = value.split(/[\t\n\r ]+/g);
        const classesFullList = [];
        const classesList = [];
        let index = -1;
        while (++index < list.length) {
          ;
          (shortcut.test(list[index]) ? classesList : classesFullList).push(
            list[index]
          );
        }
        classesFull = classesFullList.length > 0 ? quoted("class", classesFullList.join(" ")) : "";
        classes = classesList.length > 0 ? "." + classesList.join(".") : "";
      } else {
        values.push(quoted(key2, value));
      }
    }
  }
  if (classesFull) {
    values.unshift(classesFull);
  }
  if (classes) {
    values.unshift(classes);
  }
  if (id) {
    values.unshift(id);
  }
  return values.length > 0 ? "{" + values.join(" ") + "}" : "";
  function quoted(key3, value) {
    return key3 + (value ? "=" + quote + stringifyEntitiesLight(value, { subset }) + quote : "");
  }
}
function inlineDirectiveLabel(node) {
  return Boolean(
    node && node.type === "paragraph" && node.data && node.data.directiveLabel
  );
}
function fence(node) {
  let size = 0;
  if (node.type === "containerDirective") {
    visitParents(node, function(node2, parents) {
      if (node2.type === "containerDirective") {
        let index = parents.length;
        let nesting = 0;
        while (index--) {
          if (parents[index].type === "containerDirective") {
            nesting++;
          }
        }
        if (nesting > size) size = nesting;
      }
    });
    size += 3;
  } else if (node.type === "leafDirective") {
    size = 2;
  } else {
    size = 1;
  }
  return ":".repeat(size);
}

// ../node_modules/micromark-extension-directive/dev/index.js
var import_dist100 = __toESM(require_dist());
var import_dist101 = __toESM(require_dist2());
var import_dist102 = __toESM(require_dist3());

// ../node_modules/micromark-extension-directive/dev/lib/syntax.js
var import_dist94 = __toESM(require_dist(), 1);
var import_dist95 = __toESM(require_dist2(), 1);
var import_dist96 = __toESM(require_dist3(), 1);

// ../node_modules/micromark-extension-directive/dev/lib/directive-container.js
var import_dist85 = __toESM(require_dist(), 1);
var import_dist86 = __toESM(require_dist2(), 1);
var import_dist87 = __toESM(require_dist3(), 1);

// ../node_modules/micromark-extension-directive/dev/lib/factory-attributes.js
var import_dist76 = __toESM(require_dist(), 1);
var import_dist77 = __toESM(require_dist2(), 1);
var import_dist78 = __toESM(require_dist3(), 1);
function factoryAttributes(effects, ok3, nok, attributesType, attributesMarkerType, attributeType, attributeIdType, attributeClassType, attributeNameType, attributeInitializerType, attributeValueLiteralType, attributeValueType, attributeValueMarker, attributeValueData, disallowEol) {
  let type;
  let marker;
  return start;
  function start(code) {
    ok(code === codes.leftCurlyBrace, "expected `{`");
    effects.enter(attributesType);
    effects.enter(attributesMarkerType);
    effects.consume(code);
    effects.exit(attributesMarkerType);
    return between;
  }
  function between(code) {
    if (code === codes.numberSign) {
      type = attributeIdType;
      return shortcutStart(code);
    }
    if (code === codes.dot) {
      type = attributeClassType;
      return shortcutStart(code);
    }
    if (code === codes.colon || code === codes.underscore || asciiAlpha(code)) {
      effects.enter(attributeType);
      effects.enter(attributeNameType);
      effects.consume(code);
      return name;
    }
    if (disallowEol && markdownSpace(code)) {
      return factorySpace(effects, between, types.whitespace)(code);
    }
    if (!disallowEol && markdownLineEndingOrSpace(code)) {
      return factoryWhitespace(effects, between)(code);
    }
    return end(code);
  }
  function shortcutStart(code) {
    const markerType = (
      /** @type {TokenType} */
      type + "Marker"
    );
    effects.enter(attributeType);
    effects.enter(type);
    effects.enter(markerType);
    effects.consume(code);
    effects.exit(markerType);
    return shortcutStartAfter;
  }
  function shortcutStartAfter(code) {
    if (code === codes.eof || code === codes.quotationMark || code === codes.numberSign || code === codes.apostrophe || code === codes.dot || code === codes.lessThan || code === codes.equalsTo || code === codes.greaterThan || code === codes.graveAccent || code === codes.rightCurlyBrace || markdownLineEndingOrSpace(code)) {
      return nok(code);
    }
    const valueType = (
      /** @type {TokenType} */
      type + "Value"
    );
    effects.enter(valueType);
    effects.consume(code);
    return shortcut2;
  }
  function shortcut2(code) {
    if (code === codes.eof || code === codes.quotationMark || code === codes.apostrophe || code === codes.lessThan || code === codes.equalsTo || code === codes.greaterThan || code === codes.graveAccent) {
      return nok(code);
    }
    if (code === codes.numberSign || code === codes.dot || code === codes.rightCurlyBrace || markdownLineEndingOrSpace(code)) {
      const valueType = (
        /** @type {TokenType} */
        type + "Value"
      );
      effects.exit(valueType);
      effects.exit(type);
      effects.exit(attributeType);
      return between(code);
    }
    effects.consume(code);
    return shortcut2;
  }
  function name(code) {
    if (code === codes.dash || code === codes.dot || code === codes.colon || code === codes.underscore || asciiAlphanumeric(code)) {
      effects.consume(code);
      return name;
    }
    effects.exit(attributeNameType);
    if (disallowEol && markdownSpace(code)) {
      return factorySpace(effects, nameAfter, types.whitespace)(code);
    }
    if (!disallowEol && markdownLineEndingOrSpace(code)) {
      return factoryWhitespace(effects, nameAfter)(code);
    }
    return nameAfter(code);
  }
  function nameAfter(code) {
    if (code === codes.equalsTo) {
      effects.enter(attributeInitializerType);
      effects.consume(code);
      effects.exit(attributeInitializerType);
      return valueBefore;
    }
    effects.exit(attributeType);
    return between(code);
  }
  function valueBefore(code) {
    if (code === codes.eof || code === codes.lessThan || code === codes.equalsTo || code === codes.greaterThan || code === codes.graveAccent || code === codes.rightCurlyBrace || disallowEol && markdownLineEnding(code)) {
      return nok(code);
    }
    if (code === codes.quotationMark || code === codes.apostrophe) {
      effects.enter(attributeValueLiteralType);
      effects.enter(attributeValueMarker);
      effects.consume(code);
      effects.exit(attributeValueMarker);
      marker = code;
      return valueQuotedStart;
    }
    if (disallowEol && markdownSpace(code)) {
      return factorySpace(effects, valueBefore, types.whitespace)(code);
    }
    if (!disallowEol && markdownLineEndingOrSpace(code)) {
      return factoryWhitespace(effects, valueBefore)(code);
    }
    effects.enter(attributeValueType);
    effects.enter(attributeValueData);
    effects.consume(code);
    marker = void 0;
    return valueUnquoted;
  }
  function valueUnquoted(code) {
    if (code === codes.eof || code === codes.quotationMark || code === codes.apostrophe || code === codes.lessThan || code === codes.equalsTo || code === codes.greaterThan || code === codes.graveAccent) {
      return nok(code);
    }
    if (code === codes.rightCurlyBrace || markdownLineEndingOrSpace(code)) {
      effects.exit(attributeValueData);
      effects.exit(attributeValueType);
      effects.exit(attributeType);
      return between(code);
    }
    effects.consume(code);
    return valueUnquoted;
  }
  function valueQuotedStart(code) {
    if (code === marker) {
      effects.enter(attributeValueMarker);
      effects.consume(code);
      effects.exit(attributeValueMarker);
      effects.exit(attributeValueLiteralType);
      effects.exit(attributeType);
      return valueQuotedAfter;
    }
    effects.enter(attributeValueType);
    return valueQuotedBetween(code);
  }
  function valueQuotedBetween(code) {
    if (code === marker) {
      effects.exit(attributeValueType);
      return valueQuotedStart(code);
    }
    if (code === codes.eof) {
      return nok(code);
    }
    if (markdownLineEnding(code)) {
      return disallowEol ? nok(code) : factoryWhitespace(effects, valueQuotedBetween)(code);
    }
    effects.enter(attributeValueData);
    effects.consume(code);
    return valueQuoted;
  }
  function valueQuoted(code) {
    if (code === marker || code === codes.eof || markdownLineEnding(code)) {
      effects.exit(attributeValueData);
      return valueQuotedBetween(code);
    }
    effects.consume(code);
    return valueQuoted;
  }
  function valueQuotedAfter(code) {
    return code === codes.rightCurlyBrace || markdownLineEndingOrSpace(code) ? between(code) : end(code);
  }
  function end(code) {
    if (code === codes.rightCurlyBrace) {
      effects.enter(attributesMarkerType);
      effects.consume(code);
      effects.exit(attributesMarkerType);
      effects.exit(attributesType);
      return ok3;
    }
    return nok(code);
  }
}

// ../node_modules/micromark-extension-directive/dev/lib/factory-label.js
var import_dist79 = __toESM(require_dist(), 1);
var import_dist80 = __toESM(require_dist2(), 1);
var import_dist81 = __toESM(require_dist3(), 1);
function factoryLabel(effects, ok3, nok, type, markerType, stringType, disallowEol) {
  let size = 0;
  let balance = 0;
  let previous2;
  return start;
  function start(code) {
    ok(code === codes.leftSquareBracket, "expected `[`");
    effects.enter(type);
    effects.enter(markerType);
    effects.consume(code);
    effects.exit(markerType);
    return afterStart;
  }
  function afterStart(code) {
    if (code === codes.rightSquareBracket) {
      effects.enter(markerType);
      effects.consume(code);
      effects.exit(markerType);
      effects.exit(type);
      return ok3;
    }
    effects.enter(stringType);
    return lineStart(code);
  }
  function lineStart(code) {
    if (code === codes.rightSquareBracket && !balance) {
      return atClosingBrace(code);
    }
    const token = effects.enter(types.chunkText, {
      contentType: constants.contentTypeText,
      previous: previous2
    });
    if (previous2) previous2.next = token;
    previous2 = token;
    return data(code);
  }
  function data(code) {
    if (code === codes.eof || size > constants.linkReferenceSizeMax) {
      return nok(code);
    }
    if (code === codes.leftSquareBracket && ++balance > constants.linkResourceDestinationBalanceMax) {
      return nok(code);
    }
    if (code === codes.rightSquareBracket && !balance--) {
      effects.exit(types.chunkText);
      return atClosingBrace(code);
    }
    if (markdownLineEnding(code)) {
      if (disallowEol) {
        return nok(code);
      }
      effects.consume(code);
      effects.exit(types.chunkText);
      return lineStart;
    }
    effects.consume(code);
    return code === codes.backslash ? dataEscape : data;
  }
  function dataEscape(code) {
    if (code === codes.leftSquareBracket || code === codes.backslash || code === codes.rightSquareBracket) {
      effects.consume(code);
      size++;
      return data;
    }
    return data(code);
  }
  function atClosingBrace(code) {
    effects.exit(stringType);
    effects.enter(markerType);
    effects.consume(code);
    effects.exit(markerType);
    effects.exit(type);
    return ok3;
  }
}

// ../node_modules/micromark-extension-directive/dev/lib/factory-name.js
var import_dist82 = __toESM(require_dist(), 1);
var import_dist83 = __toESM(require_dist2(), 1);
var import_dist84 = __toESM(require_dist3(), 1);
function factoryName(effects, ok3, nok, type) {
  const self = this;
  return start;
  function start(code) {
    if (asciiAlpha(code)) {
      effects.enter(type);
      effects.consume(code);
      return name;
    }
    return nok(code);
  }
  function name(code) {
    if (code === codes.dash || code === codes.underscore || asciiAlphanumeric(code)) {
      effects.consume(code);
      return name;
    }
    effects.exit(type);
    return self.previous === codes.dash || self.previous === codes.underscore ? nok(code) : ok3(code);
  }
}

// ../node_modules/micromark-extension-directive/dev/lib/directive-container.js
var directiveContainer = {
  tokenize: tokenizeDirectiveContainer,
  concrete: true
};
var label = { tokenize: tokenizeLabel, partial: true };
var attributes2 = { tokenize: tokenizeAttributes, partial: true };
var nonLazyLine = { tokenize: tokenizeNonLazyLine, partial: true };
function tokenizeDirectiveContainer(effects, ok3, nok) {
  const self = this;
  const tail = self.events[self.events.length - 1];
  const initialSize = tail && tail[1].type === types.linePrefix ? tail[2].sliceSerialize(tail[1], true).length : 0;
  let sizeOpen = 0;
  let previous2;
  return start;
  function start(code) {
    ok(code === codes.colon, "expected `:`");
    effects.enter("directiveContainer");
    effects.enter("directiveContainerFence");
    effects.enter("directiveContainerSequence");
    return sequenceOpen(code);
  }
  function sequenceOpen(code) {
    if (code === codes.colon) {
      effects.consume(code);
      sizeOpen++;
      return sequenceOpen;
    }
    if (sizeOpen < constants.codeFencedSequenceSizeMin) {
      return nok(code);
    }
    effects.exit("directiveContainerSequence");
    return factoryName.call(
      self,
      effects,
      afterName,
      nok,
      "directiveContainerName"
    )(code);
  }
  function afterName(code) {
    return code === codes.leftSquareBracket ? effects.attempt(label, afterLabel, afterLabel)(code) : afterLabel(code);
  }
  function afterLabel(code) {
    return code === codes.leftCurlyBrace ? effects.attempt(attributes2, afterAttributes, afterAttributes)(code) : afterAttributes(code);
  }
  function afterAttributes(code) {
    return factorySpace(effects, openAfter, types.whitespace)(code);
  }
  function openAfter(code) {
    effects.exit("directiveContainerFence");
    if (code === codes.eof) {
      return afterOpening(code);
    }
    if (markdownLineEnding(code)) {
      if (self.interrupt) {
        return ok3(code);
      }
      return effects.attempt(nonLazyLine, contentStart, afterOpening)(code);
    }
    return nok(code);
  }
  function afterOpening(code) {
    effects.exit("directiveContainer");
    return ok3(code);
  }
  function contentStart(code) {
    if (code === codes.eof) {
      effects.exit("directiveContainer");
      return ok3(code);
    }
    effects.enter("directiveContainerContent");
    return lineStart(code);
  }
  function lineStart(code) {
    if (code === codes.eof) {
      return after(code);
    }
    return effects.attempt(
      { tokenize: tokenizeClosingFence, partial: true },
      after,
      initialSize ? factorySpace(effects, chunkStart, types.linePrefix, initialSize + 1) : chunkStart
    )(code);
  }
  function chunkStart(code) {
    if (code === codes.eof) {
      return after(code);
    }
    const token = effects.enter(types.chunkDocument, {
      contentType: constants.contentTypeDocument,
      previous: previous2
    });
    if (previous2) previous2.next = token;
    previous2 = token;
    return contentContinue(code);
  }
  function contentContinue(code) {
    if (code === codes.eof) {
      const t = effects.exit(types.chunkDocument);
      self.parser.lazy[t.start.line] = false;
      return after(code);
    }
    if (markdownLineEnding(code)) {
      return effects.check(nonLazyLine, nonLazyLineAfter, lineAfter)(code);
    }
    effects.consume(code);
    return contentContinue;
  }
  function nonLazyLineAfter(code) {
    effects.consume(code);
    const t = effects.exit(types.chunkDocument);
    self.parser.lazy[t.start.line] = false;
    return lineStart;
  }
  function lineAfter(code) {
    const t = effects.exit(types.chunkDocument);
    self.parser.lazy[t.start.line] = false;
    return after(code);
  }
  function after(code) {
    effects.exit("directiveContainerContent");
    effects.exit("directiveContainer");
    return ok3(code);
  }
  function tokenizeClosingFence(effects2, ok4, nok2) {
    let size = 0;
    ok(self.parser.constructs.disable.null, "expected `disable.null`");
    return factorySpace(
      effects2,
      closingPrefixAfter,
      types.linePrefix,
      self.parser.constructs.disable.null.includes("codeIndented") ? void 0 : constants.tabSize
    );
    function closingPrefixAfter(code) {
      effects2.enter("directiveContainerFence");
      effects2.enter("directiveContainerSequence");
      return closingSequence(code);
    }
    function closingSequence(code) {
      if (code === codes.colon) {
        effects2.consume(code);
        size++;
        return closingSequence;
      }
      if (size < sizeOpen) return nok2(code);
      effects2.exit("directiveContainerSequence");
      return factorySpace(effects2, closingSequenceEnd, types.whitespace)(code);
    }
    function closingSequenceEnd(code) {
      if (code === codes.eof || markdownLineEnding(code)) {
        effects2.exit("directiveContainerFence");
        return ok4(code);
      }
      return nok2(code);
    }
  }
}
function tokenizeLabel(effects, ok3, nok) {
  return factoryLabel(
    effects,
    ok3,
    nok,
    "directiveContainerLabel",
    "directiveContainerLabelMarker",
    "directiveContainerLabelString",
    true
  );
}
function tokenizeAttributes(effects, ok3, nok) {
  return factoryAttributes(
    effects,
    ok3,
    nok,
    "directiveContainerAttributes",
    "directiveContainerAttributesMarker",
    "directiveContainerAttribute",
    "directiveContainerAttributeId",
    "directiveContainerAttributeClass",
    "directiveContainerAttributeName",
    "directiveContainerAttributeInitializerMarker",
    "directiveContainerAttributeValueLiteral",
    "directiveContainerAttributeValue",
    "directiveContainerAttributeValueMarker",
    "directiveContainerAttributeValueData",
    true
  );
}
function tokenizeNonLazyLine(effects, ok3, nok) {
  const self = this;
  return start;
  function start(code) {
    ok(markdownLineEnding(code), "expected eol");
    effects.enter(types.lineEnding);
    effects.consume(code);
    effects.exit(types.lineEnding);
    return lineStart;
  }
  function lineStart(code) {
    return self.parser.lazy[self.now().line] ? nok(code) : ok3(code);
  }
}

// ../node_modules/micromark-extension-directive/dev/lib/directive-leaf.js
var import_dist88 = __toESM(require_dist(), 1);
var import_dist89 = __toESM(require_dist2(), 1);
var import_dist90 = __toESM(require_dist3(), 1);
var directiveLeaf = { tokenize: tokenizeDirectiveLeaf };
var label2 = { tokenize: tokenizeLabel2, partial: true };
var attributes3 = { tokenize: tokenizeAttributes2, partial: true };
function tokenizeDirectiveLeaf(effects, ok3, nok) {
  const self = this;
  return start;
  function start(code) {
    ok(code === codes.colon, "expected `:`");
    effects.enter("directiveLeaf");
    effects.enter("directiveLeafSequence");
    effects.consume(code);
    return inStart;
  }
  function inStart(code) {
    if (code === codes.colon) {
      effects.consume(code);
      effects.exit("directiveLeafSequence");
      return factoryName.call(
        self,
        effects,
        afterName,
        nok,
        "directiveLeafName"
      );
    }
    return nok(code);
  }
  function afterName(code) {
    return code === codes.leftSquareBracket ? effects.attempt(label2, afterLabel, afterLabel)(code) : afterLabel(code);
  }
  function afterLabel(code) {
    return code === codes.leftCurlyBrace ? effects.attempt(attributes3, afterAttributes, afterAttributes)(code) : afterAttributes(code);
  }
  function afterAttributes(code) {
    return factorySpace(effects, end, types.whitespace)(code);
  }
  function end(code) {
    if (code === codes.eof || markdownLineEnding(code)) {
      effects.exit("directiveLeaf");
      return ok3(code);
    }
    return nok(code);
  }
}
function tokenizeLabel2(effects, ok3, nok) {
  return factoryLabel(
    effects,
    ok3,
    nok,
    "directiveLeafLabel",
    "directiveLeafLabelMarker",
    "directiveLeafLabelString",
    true
  );
}
function tokenizeAttributes2(effects, ok3, nok) {
  return factoryAttributes(
    effects,
    ok3,
    nok,
    "directiveLeafAttributes",
    "directiveLeafAttributesMarker",
    "directiveLeafAttribute",
    "directiveLeafAttributeId",
    "directiveLeafAttributeClass",
    "directiveLeafAttributeName",
    "directiveLeafAttributeInitializerMarker",
    "directiveLeafAttributeValueLiteral",
    "directiveLeafAttributeValue",
    "directiveLeafAttributeValueMarker",
    "directiveLeafAttributeValueData",
    true
  );
}

// ../node_modules/micromark-extension-directive/dev/lib/directive-text.js
var import_dist91 = __toESM(require_dist(), 1);
var import_dist92 = __toESM(require_dist2(), 1);
var import_dist93 = __toESM(require_dist3(), 1);
var directiveText = {
  tokenize: tokenizeDirectiveText,
  previous
};
var label3 = { tokenize: tokenizeLabel3, partial: true };
var attributes4 = { tokenize: tokenizeAttributes3, partial: true };
function previous(code) {
  return code !== codes.colon || this.events[this.events.length - 1][1].type === types.characterEscape;
}
function tokenizeDirectiveText(effects, ok3, nok) {
  const self = this;
  return start;
  function start(code) {
    ok(code === codes.colon, "expected `:`");
    ok(previous.call(self, self.previous), "expected correct previous");
    effects.enter("directiveText");
    effects.enter("directiveTextMarker");
    effects.consume(code);
    effects.exit("directiveTextMarker");
    return factoryName.call(self, effects, afterName, nok, "directiveTextName");
  }
  function afterName(code) {
    return code === codes.colon ? nok(code) : code === codes.leftSquareBracket ? effects.attempt(label3, afterLabel, afterLabel)(code) : afterLabel(code);
  }
  function afterLabel(code) {
    return code === codes.leftCurlyBrace ? effects.attempt(attributes4, afterAttributes, afterAttributes)(code) : afterAttributes(code);
  }
  function afterAttributes(code) {
    effects.exit("directiveText");
    return ok3(code);
  }
}
function tokenizeLabel3(effects, ok3, nok) {
  return factoryLabel(
    effects,
    ok3,
    nok,
    "directiveTextLabel",
    "directiveTextLabelMarker",
    "directiveTextLabelString"
  );
}
function tokenizeAttributes3(effects, ok3, nok) {
  return factoryAttributes(
    effects,
    ok3,
    nok,
    "directiveTextAttributes",
    "directiveTextAttributesMarker",
    "directiveTextAttribute",
    "directiveTextAttributeId",
    "directiveTextAttributeClass",
    "directiveTextAttributeName",
    "directiveTextAttributeInitializerMarker",
    "directiveTextAttributeValueLiteral",
    "directiveTextAttributeValue",
    "directiveTextAttributeValueMarker",
    "directiveTextAttributeValueData"
  );
}

// ../node_modules/micromark-extension-directive/dev/lib/syntax.js
function directive() {
  return {
    text: { [codes.colon]: directiveText },
    flow: { [codes.colon]: [directiveContainer, directiveLeaf] }
  };
}

// ../node_modules/micromark-extension-directive/dev/lib/html.js
var import_dist97 = __toESM(require_dist(), 1);
var import_dist98 = __toESM(require_dist2(), 1);
var import_dist99 = __toESM(require_dist3(), 1);
var own3 = {}.hasOwnProperty;

// ../node_modules/remark-directive/lib/index.js
function remarkDirective() {
  const self = (
    /** @type {Processor} */
    this
  );
  const data = self.data();
  const micromarkExtensions = data.micromarkExtensions || (data.micromarkExtensions = []);
  const fromMarkdownExtensions = data.fromMarkdownExtensions || (data.fromMarkdownExtensions = []);
  const toMarkdownExtensions = data.toMarkdownExtensions || (data.toMarkdownExtensions = []);
  micromarkExtensions.push(directive());
  fromMarkdownExtensions.push(directiveFromMarkdown());
  toMarkdownExtensions.push(directiveToMarkdown());
}
export {
  remarkDirective as default
};
//# sourceMappingURL=remark-directive.js.map
